* MEMORE for SAS Version 3.0;
* Copyright 2025 ;
* by Amanda Kay Montoya and Andrew F. Hayes;
* akmontoya.com;
* akmontoya@ucla.edu ;
* Documentation available online at github.com/akmontoya/memore;
* Report bugs or issues at github.com/akmontoya/memore;

* Permission is hereby granted, free of charge, to any person obtaining a copy of this ;
* software and associated documentation files (the "Software"), to use the software ;
* in this form.  Distribution after modification is prohibited, as is its use for any ;  
* commercial purpose without authorization. This software should not be posted or ;
* stored on any webpage, server, or directory accessible to the public whether free ;
* or for a charge unless written permission has been granted by the copyright holder.;
* The copyright holder requests that this software be distributed by directing users ;
* to akmontoya.com where the latest release of the software and documentation is ;
* archived and  can be downloaded.*/.

* THIS SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, ;
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF ;
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT ;
* IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ;
*  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT ;
* OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE ;
* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE ;

* The above text should be included in any distribution of the software ;

%macro cdfinvt (p=,df=);
p0=-.322232431088;p1=-1;p2=-.342242088547;p3=-.0204231210245;p4=-.0000453642210148;
q0=.0993484626060;q1=.588581570495;q2=.531103462366;q3=.103537752850;q4=.0038560700634;
ppv=&p;if (&p > .5) then;do;ppv=1-&p;end;
y5=sqrt(-2*log(ppv));
xp=y5+((((y5*p4+p3)*y5+p2)*y5+p1)*y5+p0)/((((y5*q4+q3)*y5+q2)*y5+q1)*y5+q0);
if (&p <= .5) then;do;xp=-xp;end;
toutput=sqrt(&df*(exp((&df-(5/6))*(xp##2)/(&df-(2/3)+.11/&df)##2)-1));
%mend;

%macro sobel (a=,sea=, b=, seb=);
product = &a*&b;
sobse = sqrt((&a**2)*(&seb**2)+(&b**2)*(&sea**2)); 
sobelZ = product/sobse; 
sobelp = 2*probnorm((-1)*abs(sobelZ));
sobelres = product || sobse || sobelZ ||sobelp; 
%mend;


%macro bcbootM (dat =, est = -9999);
	temp=&dat;
	temp[rank(temp)]=&dat;
	if (&est ^= -9999) then;do;
		bctemp=(&dat < &est);
		bctemp2=bctemp[+,]/samples;
		bctemp3=bctemp2;
		if (bctemp2 > .5) then;do;bctemp3=1-bctemp2;end;
		bctemp4=sqrt(-2*log(bctemp3));
	    bctemp5=bctemp4+((((bctemp4*p4+p3)*bctemp4+p2)*bctemp4+p1)*bctemp4+p0)/((((bctemp4*q4+q3)*bctemp4+q2)*bctemp4+q1)*bctemp4+q0);
		if (bctemp2 <= .5) then;do;
			bctemp5=-bctemp5;
		end;
		bcllii=probnorm(2*bctemp5-zalpha2)*nrow(&dat);
		bcucii=probnorm(2*bctemp5+zalpha2)*nrow(&dat);
		bcllii=round(bcllii);
		bcucii=floor(bcucii)+1;
		if ((bcllii < 1) | (bcucii > nrow(&dat))) then;do;
				runnotes[4,1]=4;criterr=1;bcllii=1;bcucii=nrow(&dat);
		end;
		llcit=temp[bcllii,1];
		ulcit=temp[bcucii,1];
	end; 
	if (&est = -9999) then; do;

		llcit=temp[lcii,1];
		ulcit = temp[ucii,1];
	end;
%mend bcbootM;

%macro dichot (modcount=,dat=);
dich = j(&modcount, 3, -999);
do q = 1 to &modcount;
    uniqdes = DESIGN(&dat[,q]);
	dich[q,1] = (ncol(uniqdes) = 2);
	if (dich[q,1] = 1) then;
	do;
		dichsort = J(nrow(&dat), 1, -999);
		dichgrad = rank(&dat[,q]);
		dichsort[dichgrad,1] = &dat[,q];
		dich[q,2] = dichsort[1,1]; 
		dich[q,3] = dichsort[nrow(&dat),1];
	end;
end;
%mend;

%macro probres (coef=,values=,semat=,df=);
pbresmat= &values || J(nrow(&values), 6, -999); 
values = J(nrow(&values),1,1)|| &values;
pbresmat[,ncol(&values)+1] = values*&coef;
pbresmat[,ncol(&values)+2] = sqrt(vecdiag(values*&semat*t(values)));
pbresmat[,ncol(&values)+3] = pbresmat[,ncol(&values)+1]/pbresmat[,ncol(&values)+2];
pbresmat[,ncol(&values)+4] = 2*(1-probt(abs(pbresmat[,ncol(&values)+3]), &df));
%cdfinvt(p = alpha2, df = &df);
tcritb = toutput;
pbresmat[,(ncol(&values)+5):(ncol(&values)+6)] = pbresmat[,ncol(&values)+1]-tcritb*pbresmat[,ncol(&values)+2] || pbresmat[,ncol(&values)+1]+tcritb*pbresmat[,ncol(&values)+2];
%mend;

%macro centerd(centdat =);
centdat = &centdat;
%dichot(modcount=ncol(centdat), dat = centdat);
avgs = centdat[+,]/nrow(centdat);
if(ncol(centdat)>1) then;
do;
	centmean=diag(diag(avgs[1,1:(ncol(centdat))])*(1-dich[,1]*(center=2))); 
end;
if(ncol(centdat) = 1) then;
	do;
	centmean = avgs[1,1:(ncol(centdat))]*t(1-dich[,1]*(center=2)); 
end;
outdat = centdat - J(nrow(centdat),ncol(centdat),1)*centmean;
%mend;

%macro JNprobe(coefOne=,coefTwo=,seOne=,seTwo=,cov=,critt=,dfJN=);
coefOne = &coefOne;
coefTwo = &coefTwo;
seOne = &seOne;
seTwo = &seTwo;
cov = &cov;
critt = &critt;
dfJN = &dfJN;
cquad = (coefOne**2)-(critt**2)*seOne;
bquad = 2*coefOne*coefTwo-2*(critt**2)*cov;
aquad = (coefTwo**2)-(critt**2)*seTwo;
if((bquad**2-4*cquad*aquad)>=0)then;
	do;
	JNsoln = (-1*bquad+sqrt(bquad**2-4*cquad*aquad))/(2*aquad)//(-1*bquad-sqrt(bquad**2-4*cquad*aquad))/(2*aquad);
	Solngrad = rank(JNsoln);
	JNsoln[Solngrad,1] = JNsoln[,1];
	Pcntabv = ((moddat[,1] || moddat[,1])-J(N,2,1)*diag(JNsoln)>0)[+,]/N*100;
	test1 = (Pcntabv=100)[,+];
	NumJN = 2-(Pcntabv=100)[,+]-(Pcntabv=0)[,+];
	tooHigh = (Pcntabv=0)[,+];
	tooLow = (Pcntabv=100)[,+];
	if(tooLow=1)then;
		do;
		JNsoln = JNsoln[2,1];
		Pcntabv = Pcntabv[1,2];
	end;
	if(tooHigh=1) then;
		do;
		JNsoln = JNsoln[1,1];
		Pcntabv = Pcntabv[1,1];
	end;
end;
if((bquad**2-4*cquad*aquad)<0)then;
	do;
	NumJN=0;
	JNres = j(1,1,-999);
	JNsoln = j(1,1,-999);
	Pcntabv = j(1,1,-999);
end;
print numJN;
JNWcomb = J(20+numJN,2,1);
minW = min(moddat[,1]);
maxW = max(moddat[,1]);
range = maxW - minW;
do i = 1 to 20;
	JNWcomb[i,2] = minW+range/19*(i-1);
end;
print JNWcomb;
if (NumJN>0) then JNWcomb[21:(20+numJN),2]=JNsoln;
print JNWcomb;
JNgrad = rank(JNWcomb[,2]);
JNWcomb[JNgrad,2] = JNWcomb[,2];
JNres = JNWcomb[,2]||J(nrow(JNWcomb),6,-999);
print JNres;
JNres[,2] = JNWcomb*(coefOne//coefTwo);
JNres[,3] = sqrt(vecdiag(JNWcomb*((seOne||cov)//(cov||seTwo))*t(JNWcomb)));
JNres[,4] = JNres[,2]/JNres[,3];
JNres[,5] = 2*(1-probt(abs(JNres[,4]), dfJN));
JNres[,6:7] = (JNres[,2]-critt*JNres[,3])||(JNres[,2]+critt*JNres[,3]);
print JNres;
%mend;

%macro memore (data=,y=xxxxxx,m=xxxxxx,w=xxxxxx,conf=95,mc=0,samples=5000,normal=0,bc=0,decimals=10.4,
  save=xxx,seed=0,contrast=0,xmint=1,serial=0, jn = 0, quantile = 0, plot = 0, center = 0,
  wmodval1 = 999.99, wmodval2 = 999.99, wmodval3 = 999.99, model = 1);
options pagesize=32767;
proc iml;
runnotes=j(32,1,0);
criterr=0;
model = &model; 
modelmt2 = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18};
validtst = (model = modelmt2);
validmod = any(validtst);

if (validmod ^= 1) then;
do;  
	criterr = 1;
	runnotes[23,1] = 23;
end;

w = "&w";
m = "&m";

if ((w = "xxxxxx")&(model ^= 1)) then; 
do;
	criterr = 1; 
	wnames = "xxxxxx";
	mnames = "xxxxxx";
	runnotes[21,1] = 21;
end;

if((m = "xxxxxx") & ((model = 1)|(model>=4))) then; 
do;
	criterr = 1;
	mnames = "xxxxxx";
	wnames = "xxxxxx";
	runnotes[22,1] = 22;
end;

if (criterr ^= 1) then; 
do;
	use &data;
	read all var{&y} into ydat;
	ynames = {&y};
	if (model = 1) then;
	do;
		read all var{&m} into mdat;
		mnames = {&m};
		read all var{&m &y} into data;
		names = {&m &y};
		wnames = "xxxxxx";
	end;
	if ((model=2)|(model=3))then; do;
		read all var{&w} into wdat;
		wnames = {&w};
		read all var{&w &y} into data;
		names = {&w &y};
		mnames = "xxxxxx";
	end;
	if (model >= 4) then; do;
		read all var{&m} into mdat;
		mnames = {&m};
		read all var{&w} into wdat;
		wnames = {&w};
		read all var{&w &m &y} into data;
		names = {&w &m &y};
	end;
	ninit=nrow(data);
	xx=(data = .);
	xx=xx[,+];
	j=1;do i=1 to nrow(data);if xx[i,1]=0 then;do;data[j,]=data[i,];j=j+1;end;end;
	data=data[1:j-1,];
	missing=ninit-nrow(data);
end;
mc = (&mc = 1);serial = (&serial = 1);jn = (&jn = 1); plot = (&plot = 1); quantile = (&quantile = 1);
contrast = (&contrast = 1); normal = (&normal = 1); xmint = (&xmint = 1);

if((model=1)&(plot=1)) then; do;
	plot = 0;
	runnotes[30,1] = 30;
end;

center = &center;
centervals = {0,1,2};
if(1-any(center=centervals)) then;do;
	runnotes[28,1] = 28;
	center = 0;
end;

if((model>=4)&(serial=1))then;do;
	serial = 0;
	runnotes[25,1]=25;
end;


if (((model = 2) | (model = 3)) & (ncol(wnames)> 1) & (jn = 1)) then;
	do; runnotes[16,1] = 16; jn = 0; end;

if((model=17)&(xmint=0))then;do;
	criterr=1;
	runnotes[27,1]=27;
end;

apathmod = 0; bpathmod = 0; cppthmd = 0; dpathmod = 0;
atvec = {4,5,6,7,9,10,12,15};
btvec = {4,5,6,8,9,11,13,16};
dtvec = {4,5,7,8,10,11,14,17};
cptvec = {4,6,7,8,12,13,14,18};

if(any(model=atvec))then;do;
	apathmod = 1;
end;
if(any(model=btvec))then;do;
	bpathmod = 1;
end;
if(any(model=cptvec))then;do;
	cppthmd = 1;
end;
if(any(model=dtvec))then;do;
	dpathmod = 1;
end;

anymod = apathmod+bpathmod+cppthmd+dpathmod;
anymod = (anymod > 0);

if ((xmint = 0) & (dpathmod = 1)) then; do;
	runnotes[32,1] = 32;
	criterr = 1;
end;

if(criterr ^= 1) then; do;
	if (missing > 0) then;do;runnotes[1,1]=1;end;
	if (ncol(ynames) ^= 2) then;do;runnotes[2,1]=2;criterr=1;end;
end;
mcount=ncol(mnames);
wcount = ncol(wnames);
if(any(wnames = "xxxxxx"))then;do;
	wcount = 0;
end;

if ("&save" = "") then save="xxx";else save="&save";

if ((model = 2) | (model = 3)|(anymod >0)) then; do;
	wmodval1 = {&wmodval1};
	wmodval2 = {&wmodval2};
	wmodval3 = {&wmodval3};
	yesval = J(3,1,-999);
	length = yesval;
	modvmat = J(3, wcount, -999);
	failed = 0;
	do i = 1 to 3 until (failed = 1);
		if (i = 1) then wmodval = wmodval1; 
		if (i = 2) then wmodval = wmodval2; 
		if (i = 3) then wmodval = wmodval3; 
		yesval[i,1] = ANY(wmodval - 999.99);
		length[i,1] = (ncol(wmodval) = wcount);
		if ((yesval[i,1] = 1) & (length[i,1] = 1)) then; do; 
			modvmat[i,] = wmodval; 
			setswv = i;
		end;
		if ((yesval[i,1] = 1) & (length[i,1] = 0)) then; do; runnotes[18,1] = 18; setswv = i-1; failed = 1; end;
		if (yesval[i,1] = 0) then; do; setswv = i-1; failed = 1; end;
	end;
	if (setswv > 0) then modvmat = modvmat[1:setswv,]; 
	if (setswv = 0) then modvmat = J(1,1, -999);
end;

if (((mcount < 2) | ((mcount/2) ^= floor(mcount/2)) | (mcount > 20)) & (criterr ^= 1)& ((model = 1)|(model>=4))) then; do;
  runnotes[6,1]=6;criterr=1;
end;

if(((model = 2) | (model = 3)) & ((wcount = 0) | (wcount > 5))) then; do;
	runnotes[15,1] = 15;
	criterr = 1;
end;

if((model>=4)&(wcount^=1))then;do;
	runnotes[9,1] = 9;
	criterr = 1;
end;

if (criterr = 0) then; do;
	if ((model = 1)|(model>=4)) then; do;
	  do i = 1 to mcount;
	    if ((mnames[1,i]=ynames[1,1]) | (mnames[1,i]=ynames[1,2]) | (ynames[1,1]=ynames[1,2])) then;do;
	      runnotes[8,1]=8;criterr=1;
	    end;
	  end;
	end;
	if (model ^= 1) then; do;
	  do i = 1 to Wcount;
	    if ((wnames[1,i]=ynames[1,1]) | (wnames[1,i]=ynames[1,2]) | (ynames[1,1]=ynames[1,2])) then;do;
	      runnotes[8,1]=8;criterr=1;
	    end;
	  end;
	end;
end;

if((model>=4)&(wcount>0)) then; do;
	do i = 1 to mcount;
		if(mnames[1,i] = wnames[1,1]) then; do;
			runnotes[8,1] = 8;
			criterr = 1;
		end;
	end;
end;


if ((serial=1) & (mc=1)) then;do;
  runnotes[12,1]=12;mc=0;
end;

if (criterr <> 1) then; do;
	zero=j(nrow(data),1,0);
	do i = 1 to (ncol(data)-1);
	  	do j = i + 1 TO (ncol(data));
		  	diff=data[,i]-data[,j];
		  	copy=(diff=zero);copy=copy[+];
		  	if (copy=nrow(data)) then;do;
		    	copyname=names[1,i]||names[1,j];
				runnotes[7,1]=7;criterr=1;
		  	end;
	  	end;
	end;
end;

if (&samples = 0) then;do;
  samples=5000;mc=1;
end;
if (&samples ^=0) then;do;
  samples = &samples;
* samples=abs(floor(&samples))*(abs(floor(&samples))>=1000)+5000*(abs(floor(&samples))<1000);
end;
if (samples ^= &samples) then;do;
  runnotes[3,1]=3;
end;

conf=&conf;
if ((&conf < 50) | (&conf > 99.99)) then; do;
	conf=95;
	runnotes[5,1]=5;
end;

bc=floor(&bc);if ((mc=1) & (bc=1)) then;do;runnotes[9,1]=9;bc=0;end;
if ((contrast=1) & ((mcount/2)=1) & (model = 1)) then runnotes[10,1]=10;
if ((contrast = 1) & (serial = 1) & (mcount > 6) & (model = 1)) then; do;
	contrast = 0;
	runnotes[20,1] = 20;
end;

if((contrast=1) & ((apathmod=1)|(bpathmod=1))) then; do;
	contrast = 0;
	runnotes[26,1] = 26;
end;

if (((mcount < 4) | (mcount > 10)) & ((model = 1)|(model >=4)) & (serial = 1)) then; do;
	runnotes[13,1] = 13;
	criterr = 1;
end;

if ((model = 1)&(center > 0)) then; do;
	runnotes[24,1] = 24;
end;

savboot=0;
if ((save ^= "xxx") & (samples > 0)) then;do;savboot=1;
end;


if (criterr = 0) then; do;
n=nrow(data);
	if (model = 3) then; do;
		intcount = J(wcount,1,-999);
		do i = 1 to wcount;
			intcount[i,1] = comb(wcount,i);
		end;
		nfail = wcount + intcount[+,1] + 2;
	end;
	if (model = 2) then; do;
		nfail = wcount + 2;
	end;
	if (model = 1) then; do;
		nfail = mcount + 2;
	end;
	if(model >= 4) then; do;
		nfail = 2*mcount+3;
	end;
	if (n < nfail) then; do; 
		runnotes[19,1] = 19;
		criterr = 1;
	end;
end;
if (criterr=0) then;do; *1;

  if ((model = 1)|(model>=4)) then; do;
    mpairs=mcount/2;
  	mnamemat=shape(mnames,mpairs,2);
  	transmat={1 0.5, -1 0.5};
  	tmat=j(ncol(data),ncol(data),0);
	if(model >=4) then; do;
		tmat[1:wcount,1:wcount] = I(wcount);
	end;
  	do i = (1+Wcount) to (2*mpairs+1+Wcount) by 2;
   	 tmat[i:(i+1),i:(i+1)]=transmat;
  	end;
  datat=data*tmat;
  select = {1 3 5 7 9 11 13 15 17 19 21};
  if (model >=4) then; do; 
  	select = 1:wcount || select+wcount;
  end;
  if (xmint = 0) then; dataT = dataT[,select[1:(Mpairs+1+Wcount)]];
  if (xmint = 1) then; do;
	dataT = datat[,1:(ncol(datat)-1)];
	do j = (Wcount+2) to (ncol(dataT)-1) by 2;
		summean = dataT[+,j]/N;
		dataT[,j] = (dataT[,j] - summean);
	end;
  end;

  if (anymod = 1) then; do;
  	moddat = dataT[,1:wcount];
	if (center > 0) then; do;
		%centerd(centdat = moddat);
		dataT[,1:Wcount] = outdat;
		moddat = outdat;
	end;
	do i = (wcount+1) to (ncol(dataT) - 1) by (1+xmint);
		if (bpathmod = 1) then; do;
			test = moddat[,1]#dataT[,i];
			moddat = moddat || moddat[,1]#dataT[,i];
		end;
		if (dpathmod = 1) then; do;
			moddat = moddat || moddat[,1]#dataT[,i+1];
		end;
	end;
	
  end;

end;
  if (model = 2) then; do;
  	mpairs = 0;
	moddat = data[,1:wcount];
  	tempvec = J(wcount,1,0);
	temp2 = {1, -1};
	tempvec = tempvec // temp2;
	transmat = (I(wcount)//J(2, wcount,0)) ||tempvec;
	datat = data*transmat;
	if (center > 0) then; do;
		%centerd(centdat = moddat);
		centmean = diag(moddat[+,]/n);
		dataT[,1:wcount] = outdat;
		moddat = outdat;
	end;
  end;
  if (model = 3) then;do;
    mpairs = 0;
	moddat = data[,1:wcount];
	tempvec = J(wcount,1,0);
	temp2 = {1, -1};
	tempvec = tempvec // temp2;
	transmat = (I(wcount)//J(2, wcount,0)) ||tempvec;
	datat = data*transmat;
	if (center > 0) then; do;
		%centerd(centdat = moddat);
		datat[,1:wcount] = outdat;
		moddat = outdat;
	end;
	if (wcount > 1) then; do;
		do h = 1 to (wcount - 1);
			do i = 1 to (wcount - h);
				counter1 = comb(wcount - i, h);
				counter2 = intcount[1:h, 1];
				do j = (sum(counter2) - counter1 + 1) to (sum(counter2));
					moddat = moddat || (moddat[,i]#moddat[,j]);
				end;
			end;
		end;
	end;
	tempvec = J(ncol(moddat),1,0);
	tempvec = tempvec // {1, -1};
	transmat = (I(ncol(moddat))//J(2, (ncol(moddat)),0)) ||tempvec;
	data = moddat || data[,(ncol(data)-1):ncol(data)];
	datat = data*transmat;
  end;
  
  alpha=(1-.01*conf);
  alpha2=alpha/2;

if ((model = 1)|(model >=4)) then; do; *3;
  aresmat=j(mpairs*(1+apathmod),6,-999);
  ades=j(n,1,1);
  if(apathmod=1) then; do;
  	ades = ades || dataT[,1:wcount];
	amodsum = j(mpairs,7, -999);
  end;
  %cdfinvt (p=alpha2,df=(n-ncol(ades)));
  tcrita=toutput;
  tcritc=toutput;
  
  counterj = 1;
  sem3aall = j(ncol(ades)*mpairs, ncol(ades), -999);
  aWcount = (apathmod = 1)*Wcount;

  do j = 1 to mpairs;
  	colj = (1+xmint)*j + Wcount - xmint;
	rowj = j*(1+aWcount) - aWcount;
	if(det(t(ades)*ades) = 0) then; do;
		criterr = 1;
		runnotes[29,1] = 29;
	end;
	avec = inv(t(ades)*ades)*t(ades)*dataT[,colj];
	M3pred = ades*avec;
	M3ssr = ((dataT[,colj]-M3pred)##2)[+,];
	M3sst = ((dataT[,colj]-dataT[+,colj]/N)##2)[+,];
	M3Rsq = 1 - M3ssr/m3sst;
	Rsqmat = 0||M3rsq ;
	M3r = sqrt(max(Rsqmat));
	M3df1 = ncol(ades) - 1;
	M3df2 = (N - ncol(ades));
	m3msr = m3ssr/m3df2;

	if(apathmod = 1) then; do;
		M3F = m3df2*m3rsq/(m3df1*(1-m3rsq));
		m3p = 1-probf(M3F, m3df1, m3df2);
		amodsum[j,] = M3r||m3rsq||m3msr||m3F||m3df1||m3df2||m3p;
	end;

	sem3amat = (m3msr*inv(t(ades)*ades));
	sem3aall[rowj:(rowj+aWcount),] = sem3amat;
	sem3a = (vecdiag(sem3amat))##(1/2);
	aresmat[rowj:(rowj+aWcount),1] = avec;
	aresmat[rowj:(rowj+aWcount),2] = sem3a;
	aresmat[rowj:(rowj+aWcount),3] = avec#(1/sem3a);
	aresmat[rowj:(rowj+aWcount),4] = 2*(1-probt(abs(aresmat[rowj:(rowj+aWcount),3]),m3df2));
	aresmat[rowj:(rowj+aWcount),5] = aresmat[rowj:(rowj+aWcount),1]-tcrita*aresmat[rowj:(rowj+aWcount),2];
	aresmat[rowj:(rowj+aWcount),6] = aresmat[rowj:(rowj+aWcount),1]+tcrita*aresmat[rowj:(rowj+aWcount),2];

  end;

  ccols = ncol(dataT);
  cols = 0;
  cdes = J(N,1,1);
  if (anymod > 0) then; cdes = cdes || dataT[,1:Wcount];
  if (det(t(cdes)*cdes)=0) then; do;
  	criterr = 1;
	runnotes[29,1] = 29;
	cvec = J(ncol(cdes), 1, -999);
  end;
  if (det(t(cdes)*cdes)^=0) then; do;
  	cvec = inv(cdes`*cdes)*cdes`*datat[,ccols];
  end;
  M4pred = cdes*cvec;
  M4ssr = ((dataT[,ccols]-M4pred)##2)[+,];
  M4sst = ((dataT[,ccols]-dataT[+,ccols]/N)##2)[+,];
  M4Rsq = 1 - M4ssr/m4sst;
  Rsqmat = 0||M4rsq ;
  M4r = sqrt(max(Rsqmat));
  M4df1 = ncol(cdes) - 1;
  M4df2 = (N - ncol(cdes));
  m4msr = m4ssr/m4df2;
  if(anymod > 0) then; do;
		M4F = m4df2*m4rsq/(m4df1*(1-m4rsq));
		m4p = 1-probf(M4F, m4df1, m4df2);
		cmodsum = M4r||m4rsq||m4msr||m4F||m4df1||m4df2||m4p;
  end;
  sem4cmat = (m4msr*inv(t(cdes)*cdes));
  sem4c = (vecdiag(sem4cmat))##(1/2);
  cresmat = J(1+Wcount, 6, -999);
  cresmat[1:(1+Wcount),1] = cvec;
  cresmat[1:(1+Wcount),2] = sem4c;
  cresmat[1:(1+Wcount),3] = cvec#(1/sem4c);
  cresmat[1:(1+Wcount),4] = 2*(1-probt(abs(cresmat[1:(1+Wcount),3]),m4df2));
  cresmat[1:(1+Wcount),5] = cresmat[1:(1+Wcount),1]-tcritc*cresmat[1:(1+Wcount),2];
  cresmat[1:(1+Wcount),6] = cresmat[1:(1+Wcount),1]+tcritc*cresmat[1:(1+Wcount),2];

  if (serial=1) then;do;
  	if (xmint = 1) then cols = mpairs##2 -1;
	if (xmint = 0) then cols = ((mpairs - 1)##2 + 3*(mpairs - 1))/2;	
	serres=j(cols,6,0);
	smodsum = j(mpairs - 1, 7, -999);
	start = 1;
	counterj = 1;
	do j = (2+xmint) to (ncol(dataT) - 1) by (1+xmint);
		serdes=j(n,1,1);serdes=serdes||dataT[,1:(j-1)];
		if(det(t(serdes)*serdes)=0) then; do;
			criterr = 1;
			runnotes[29,1]=29;
			M2modbs = j(ncols(serdes),1,-999);
		end;
		if(det(t(serdes)*serdes)^=0) then M2modbs=inv(serdes`*serdes)*serdes`*dataT[,j];
		M2pred=serdes*M2modbs;
	    M2ssr=(datat[,j]-M2pred)##2;M2ssr=M2ssr[+,];
	    tempmn=datat[,j];tempmn=tempmn[+,]/n;
	    M2sst=(datat[,j]-tempmn)##2;M2sst=M2sst[+,];    
		M2Rsq=1-(M2ssr/m2sst);
		Rsqmat = 0||M2Rsq;
		m2r=sqrt(max(Rsqmat));
	    M2msr=M2ssr/(N-ncol(serdes));
		M2df1=ncol(serdes)-1;
		M2df2=(N-ncol(serdes));
		if (m2rsq = 1) then M2F = -999;
		if (m2rsq ^= 1) then M2F=(m2df2*m2rsq)/(m2df1*(1-m2rsq));
		if(det(t(serdes)*serdes)=0) then sem2bmat = J(ncol(serdes), ncol(serdes), 999##2);
		if(det(t(serdes)*serdes)^=0) then sem2bmat = (m2msr*inv(serdes`*serdes));
		M2p=1-probf(M2F,M2df1,M2df2);
		sem2b=sqrt(vecdiag(sem2bmat));
	    smodsum[counterj,]=M2r||m2rsq||m2msr||m2F||m2df1||m2df2||m2p;
		if (xmint = 1) then end = (counterj +1)##2 - 1;
		if (xmint = 0) then end = (counterj##2 + 3*counterj)/2;
	    %cdfinvt (p=alpha2,df=m2df2);
	    sercritt=toutput;
		serres[start:end,1]=m2modbs;
		serres[start:end,2]=sem2b;
		serres[start:end,3]=serres[start:end,1]/serres[start:end,2];
		serres[start:end,4]=2*(1-probt(abs(serres[start:end,3]),m2df2));
		serres[start:end,5]=serres[start:end,1]-sercritt*serres[start:end,2];
		serres[start:end,6]=serres[start:end,1]+sercritt*serres[start:end,2];
		aresmat[counterj+1,]=serres[start,];
		start = end+1;
		counterj = counterj + 1;
	end; *doloop;
  end;*serialif;
end; *3;

*For all Models;
  bcpdes=j(n,1,1)||datat[,(1+anymod):(ncol(datat)-1)];
  if (cppthmd = 1) then; do;
  	bcpdes = j(n,1,1)||datat[,1:(ncol(datat)-1)];
  end;
  if ((bpathmod = 1)|(dpathmod=1)) then; do;
  	bcpdes = bcpdes||moddat[,2:ncol(moddat)];
  end;
  if (det(bcpdes`*bcpdes) = 0) then; do;
  	criterr = 1;
	runnotes[29,1] = 29;
	bcpvec = j(ncol(bcpdes), 1, -999);
	sebcpmat = j(ncol(bcpdes), ncol(bcpdes), 1);
  end;
  if (det(bcpdes`*bcpdes) ^= 0) then; do;
 	bcpvec=inv(bcpdes`*bcpdes)*bcpdes`*datat[,ncol(datat)];
  end;

  ypred=bcpdes*bcpvec;
  ssr=(datat[,(ncol(datat))]-ypred)##2;ssr=ssr[+,];
  tempmn=datat[,(ncol(datat))];tempmn=tempmn[+,]/n;
  sst=(datat[,(ncol(datat))]-tempmn)##2;sst=sst[+,];
  msr=ssr/(n-ncol(bcpdes));
  rsqfull=1-ssr/sst;
  rfull=sqrt(rsqfull);
  df1=ncol(bcpdes)-1;df2=n-ncol(bcpdes);
  Ffull=(df2*rsqfull)/(df1*(1-rsqfull));
  pfull=1-probf(Ffull,df1,df2);
  if (det(bcpdes`*bcpdes) ^= 0) then; do;
	sebcpmat = (msr*inv(bcpdes`*bcpdes));
  end;
  sebcp=sqrt(vecdiag(sebcpmat));
  modsumr = rfull || rsqfull || msr || ffull || df1 || df2 || pfull;
  %cdfinvt (p=alpha2,df=df2);
  tcritb=toutput;tcritcp=toutput;tcritd=toutput;

  lcii=floor((1-.01*conf)/2*samples);
  ucii=floor((1-((1-.01*conf)/2))*samples)+1;
  if ((lcii < 1) | (ucii > samples)) then; do;runnotes[4,1]=4;criterr=1;lcii=1;ucii=samples;end;

if ((model ^= 2)&(model^=3)&(criterr = 0)) then; do; *3;
    bresmat=j(mpairs*(bpathmod+1),6,-999);
    dresmat=j(mpairs*(dpathmod+1),6,-999);
	cpresmat = j(cppthmd+1, 6, -999);
	serind = 0;
	do i = 2 to mpairs;
		rchoosek = comb(mpairs, i);
		serind = serind + rchoosek;
	end;
    indres=j(Mpairs*(1+(apathmod=1))*(1+(bpathmod=1))+1+serind*(serial=1),1,0);
   if (normal=1) then;do;
     normres=j(Mpairs*(1+(apathmod=1))*(1+(bpathmod=1))+serind*(serial=1),4,0);
   end;
  cpindx = 1+cppthmd;
  cpresmat[1:cpindx,1] = bcpvec[1:cpindx,1];
  cpresmat[1:cpindx,2] = sebcp[1:cpindx,1];
  cpresmat[1:cpindx,3] = bcpvec[1:cpindx,1]/sebcp[1:cpindx,1];
  cpresmat[1:cpindx,4] = 2*(1-probt(abs(cpresmat[1:cpindx,3]), df2));
  cpresmat[1:cpindx,5] = bcpvec[1:cpindx,1]-tcritcp*sebcp[1:cpindx,1];
  cpresmat[1:cpindx,6] = bcpvec[1:cpindx,1]+tcritcp*sebcp[1:cpindx,1];

*MC Setup*;
if (mc = 1) then;do;
    mcsamps=samples;
	u = j(mcsamps,mpairs*(bpathmod+1));
	call randgen(u, "Uniform");
	u1 = u;
	call randgen(u, "Uniform");
	u2 = u;
    randsamp=sqrt(-2*log(u1))#cos((2*3.14159265358979)*(u2));
	mcres=j(mpairs*(1+(apathmod=1))*(1+(bpathmod=1))+1+serind*(serial=1),4,0);
	bindices = j(mpairs*(1+bpathmod),1,0);
	do i = 1 to mpairs;
		bindices[i,1] = 2+cppthmd+(1+xmint)*(i-1);
	end;
	if (bpathmod=1)then; do;
		seq = {1,2,3,4,5,6,7,8,9,10};
		bindices[(mpairs+1):(2*mpairs),1] = seq[1:mpairs,1]+(1+cppthmd+mpairs*(1+xmint));
	end;
	mccorr = sebcpmat[bindices, bindices];
	rndnb=randsamp*root(mccorr);
	u = j(mcsamps,mpairs*(apathmod+1));
	call randgen(u, "Uniform");
	u1 = u;
	call randgen(u, "Uniform");
	u2 = u;
    rndna=sqrt(-2*log(u1))#cos((2*3.14159265358979)*(u2));
    mcsave=j(samples,mpairs*(2+apathmod+bpathmod),0);
	totsav = Mpairs*(2+apathmod+bpathmod);
	mcind=j(samples,nrow(indres),0);
end;

**Loop for simple effects;
counteri = 1;
do i = (2+cppthmd) to (1+cppthmd+mpairs*(1+xmint)) by (1+xmint);
    bpath=bcpvec[i,1];sebpath=sebcp[i,1];
	tbpath=bpath/sebpath;
	pbpath=2*(1-probt(abs(tbpath),df2));
	lcib=bpath-tcritb*sebpath;
	ucib=bpath+tcritb*sebpath;
	bresmat[counteri,]=bpath||sebpath||tbpath||pbpath||lcib||ucib;
	if ((xmint = 1)&(counteri <= nrow(dresmat))) then; do;
		dpath=bcpvec[i+1,1];
		sedpath=sebcp[i+1,1];
		tdpath=dpath/sedpath;
		pdpath=2*(1-probt(abs(tdpath),df2));
		lcid=dpath-tcritd*sedpath;
		ucid=dpath+tcritd*sedpath;
		dresmat[counteri,]=dpath||sedpath||tdpath||pdpath||lcid||ucid;
	end;

	** Calculating Indirects in Sample;
	aindx = counteri*(1+apathmod)-apathmod-((1+apathmod)*mpairs)*(counteri > mpairs);
	amat = aresmat[aindx:(aindx+(apathmod=1)),1];
	indirect=amat*bresmat[counteri,1];
	length = (1+apathmod)*(1+bpathmod);
	indres[(1+length/2*(counteri>mpairs)+(counteri-1-mpairs*(counteri>mpairs))*length):(1+length/2*(counteri>mpairs)+(counteri-1-mpairs*(counteri>mpairs))*length+apathmod),1] = indirect;
	if (normal = 1) then;do;
	  %sobel(a = (aresmat[aindx,1]), sea = (aresmat[aindx,2]), b = (bresmat[counteri,1]), seb = (bresmat[counteri,2]));
	  normres[((apathmod+1)*counteri-apathmod),] = sobelres;
	  if(apathmod = 1) then; do;
	  	%sobel(a = (aresmat[aindx+1,1]), sea = (aresmat[aindx+1,2]), b = (bresmat[counteri,1]), seb = (bresmat[counteri,2]));
		normres[((apathmod+1)*counteri),] = sobelres;
	  end;
	end;
	
	** Calculating Indirects in Sample;
	if (mc = 1) then;do;
	  ones = j(mcsamps,1,1);
      asamp=rndna[,counteri:(counteri+apathmod)]#(ones*t(aresmat[aindx:(aindx+apathmod),2]))+(ones*t(aresmat[aindx:(aindx+apathmod),1]));
	  bsamp=rndnb[,counteri]+bresmat[counteri,1];
	  absamp=asamp#(bsamp*j(1,ncol(asamp),1));
	  mcsave[,(1+(counteri-1)*(1+apathmod)):(counteri*(1+apathmod))]=asamp;
	  mcsave[,(1+Mpairs*(1+apathmod)+(counteri-1)*(bpathmod+1))] = bsamp;
	  mcind[,(1+length*(counteri-1)):(length*(counteri-1)+1+apathmod)] = absamp;
	  do j = 1 to ncol(absamp);
	      mcgrad=rank(absamp[,j]);
		  mcsort=absamp[,j];
		  mcsort[mcgrad]=absamp[,j];
		  mcllci=mcsort[lcii,1];
		  mculci=mcsort[ucii,1];
	      tempmn=mcsort[+,]/mcsamps;
	      tempsm=(mcsort[,1]-tempmn)##2;semc=sqrt(tempsm[+,]/(mcsamps-1));
		  mcres[j+(1+apathmod)*(counteri-1),]=indirect[j,1]||semc||mcllci||mculci;
	  end; *do j = 1 to ncol(absamp);
	end; *if (mc = 1);
	counteri = counteri + 1;
  end;

  if((bpathmod=1)|(dpathmod=1))then;do;
  	do i = (2+cppthmd+mpairs*(1+xmint)) to nrow(bcpvec) by (bpathmod+dpathmod);
		if(bpathmod = 1)then;do;
			bpath = bcpvec[i,1];
			sebpath = sebcp[i,1];
			tbpath = bpath/sebpath;
			pbpath=2*(1-probt(abs(tbpath),df2));
			lcib = bpath-tcritb*sebpath;
			ucib = bpath+tcritb*sebpath;
			bresmat[counteri,] = bpath||sebpath||tbpath||pbpath||lcib||ucib;
		end; *if(bpathmod = 1);
		if(dpathmod=1) then; do;
			dpath = bcpvec[i+bpathmod,1];
			sedpath = sebcp[i+bpathmod,1];
			tdpath = dpath/sedpath;
			pdpath=2*(1-probt(abs(tdpath),df2));
			lcid = dpath-tcritd*sedpath;
			ucid = dpath+tcritd*sedpath;
			dresmat[counteri,] = dpath||sedpath||tdpath||pdpath||lcid||ucid;
		end; *if(dpathmod=1);
		if(bpathmod=1)then;do;
			aindx = counteri*(1+apathmod)-apathmod-((1+apathmod)*mpairs)*(counteri > mpairs);
			amat = aresmat[aindx:(aindx+(apathmod=1)),1];
			indirect=amat*bresmat[counteri,1];
			length = (1+apathmod)*(1+bpathmod);
			indres[(1+length/2*(counteri>mpairs)+(counteri-1-mpairs*(counteri>mpairs))*length):(1+length/2*(counteri>mpairs)+(counteri-1-mpairs*(counteri>mpairs))*length+apathmod),1] = indirect;
			if (normal = 1) then;do;
			  %sobel(a = (aresmat[aindx,1]), sea = (aresmat[aindx,2]), b = (bresmat[counteri,1]), seb = (bresmat[counteri,2]));
			  normres[((apathmod+1)*counteri-apathmod),] = sobelres;
			  if(apathmod = 1) then; do;
			  	%sobel(a = (aresmat[aindx+1,1]), sea = (aresmat[aindx+1,2]), b = (bresmat[counteri,1]), seb = (bresmat[counteri,2]));
				normres[((apathmod+1)*counteri),] = sobelres;
			  end;
			end;
			
			** Monte Carlo confidence intervals;
			if (mc = 1) then;do;
			  ones = j(mcsamps,1,1);
		      asamp=rndna[,(counteri-mpairs):(counteri-mpairs+apathmod)]#(ones*t(aresmat[aindx:(aindx+apathmod),2]))+(ones*t(aresmat[aindx:(aindx+apathmod),1]));
			  bsamp=rndnb[,counteri]+bresmat[counteri,1];
			  absamp=asamp#(bsamp*j(1,ncol(asamp),1));
			  mcsave[,(2+Mpairs*(1+apathmod)+(counteri-mpairs-1)*(bpathmod+1))] = bsamp;
			  mcind[,(1+length*(counteri-mpairs-1)+length/2):(length*(counteri-mpairs-1)+length)] = absamp;
			  do j = 1 to ncol(absamp);
			      mcgrad=rank(absamp[,j]);
				  mcsort=absamp[,j];
				  mcsort[mcgrad]=absamp[,j];
				  mcllci=mcsort[lcii,1];
				  mculci=mcsort[ucii,1];
			      tempmn=mcsort[+,]/mcsamps;
			      tempsm=(mcsort[,1]-tempmn)##2;semc=sqrt(tempsm[+,]/(mcsamps-1));
				  mcres[j+(1+apathmod)*(counteri-1),]=indirect[j,1]||semc||mcllci||mculci;
			  end; *do j = 1 to ncol(absamp);
			end; *if (mc = 1);
		end; *if(bpathmod=1);
		counteri = counteri + 1;
	end; *do i = (2+cppthmd+mpairs*(1+xmint)) to nrow(bcpvec) by (bpathmod+dpathmod); 
  end; *if((bpathmod=1)|(dpathmod=1));



  
  * Serial Mediation indirect paths;
  if (serial = 1) then;do;
  	counter = 1; 
	indse = j(serind, mpairs+1, 1);
	do j = 1 to (mpairs - 1);
		do m = 1 to (mpairs - j);
			step1 = aresmat[m,1];
			rchoosek = comb(mpairs - m, j);
			indse[counter:(counter+rchoosek-1),1] = j(rchoosek,1,aresmat[m,2]##2);
			indse[counter:(counter+rchoosek-1),2:(mpairs+1)] = j(rchoosek, mpairs, aresmat[m,1]##2);
			do l = m to (mpairs - j);
				rchoosek = comb(mpairs-l-1, j-1);
				if (xmint = 1) then srindx2 = (l##2 - 1) + 2*m;
				if (xmint = 0) then srindx2 = l*(l+1)/2 + m;
				step2 = step1*serres[srindx2,1];
				indse[counter:(counter+rchoosek-1),2] = indse[counter:(counter+rchoosek-1),2]*(serres[srindx2,2]##2);
				tempw = 1;
				tempw = tempw || (3:(mpairs+1));
				indse[counter:(counter+rchoosek-1),tempw] = indse[counter:(counter+rchoosek-1),tempw]*(serres[srindx2,1]##2);
				if (j > 1) then; do;
					do h = (l+1) to (mpairs - j + 1);
						rchoosek = comb(mpairs - h - 1, j - 2);
						if (xmint = 1) then srindx3 = (h##2-1)+2*(l+1);
						if (xmint = 0) then srindx3 = h*(h+1)/2 + l+1;
						step3 = step2*serres[srindx3,1];
	                    indse[counter:(counter+rchoosek-1),3] =   indse[counter:(counter+rchoosek-1),3]*(serres[srindx3,2]##2);
						tempw = (1:2) || (4:(mpairs+1));
						indse[counter:(counter+rchoosek-1),tempw] = indse[counter:(counter+rchoosek-1),tempw]*(serres[srindx3,1]##2);
						if (j > 2) then; do;
							do i = (h+1) to (mpairs - j +2);
								if (xmint = 1) then srindx4 = i##2-1+2*(h-1);
								if (xmint = 0) then srindx4 = i*(i+1)/2 + h+1;
								step4 = step3*serres[srindx4,1]; 
                        		indse[counter,4] = indse[counter,4]*(serres[srindx4,2]##2);
								tempw = (1:3)||(5:(mpairs+1));
								indse[counter,tempw] = indse[counter,tempw]*(serres[srindx4,1]##2);
									if (j > 3) then; do;
										if (xmint = 1) then srindx5 = 23;
										if (xmint = 0) then srindx5 = 14;
									step5 = step4*serres[srindx5,1];
                         			indse[counter,5] =   indse[counter,5]*(serres[srindx5,2]##2);
									tempw = (1:4)||(6:(mpairs+1));
                           			indse[counter,tempw] = indse[counter,tempw]*(serres[srindx5,1]##2);
                        			indres[mpairs+counter,1] = step5*bresmat[5,1];
                        			indse[counter, 6] = indse[counter, 6]*(bresmat[5,2]**2);
	                        		indse[counter,1:5] = indse[counter,1:5]*(bresmat[5,1]**2); 
                        			counter = counter+1;
									end;
									else do;
									bindx = 5;
									if (((srindx4 < 16)&(xmint = 1))|((srindx4 < 10)&(xmint = 1))) then bindx = 4;
									if (((srindx4 < 9)&(xmint = 1))|((srindx4 < 6)&(xmint = 1))) then bindx = 3;
									if (((srindx4 < 4)&(xmint = 1))|((srindx4 < 3)&(xmint = 1))) then bindx = 2;
		                            indres[mpairs+counter,1] = step4*bresmat[bindx,1];
		                            indse[counter, 5] = indse[counter, 5]*(bresmat[bindx,2]**2);
		                            indse[counter,1:4] = indse[counter,1:4]*(bresmat[bindx,1]**2);
									if (mpairs > 4) then indse[counter,6] = 0;
									counter = counter +1;
									end;
							end;
						end;
						else do;
							bindx = 5;
							if (((srindx3 < 16)&(xmint = 1))|((srindx3 < 10)&(xmint = 1))) then bindx = 4;
							if (((srindx3 < 9)&(xmint = 1))|((srindx3 < 6)&(xmint = 1))) then bindx = 3;
							if (((srindx3 < 4)&(xmint = 1))|((srindx3 < 3)&(xmint = 1))) then bindx = 2;
							indres[mpairs+counter,1] = step3*bresmat[bindx,1];
                        	indse[counter, 4] = indse[counter, 4]*(bresmat[bindx,2]**2);
                        	indse[counter,1:3] = indse[counter,1:3]*(bresmat[bindx,1]**2); 
							if (mpairs > 3) then indse[counter, 5:(mpairs+1)] = j(1, ncol(5:(mpairs+1)), 0);
							counter = counter +1;
						end;
					end;
				end;
				else do;
					bindx = 5;
					if (((srindx2 < 16)&(xmint = 1))|((srindx2 < 10)&(xmint = 1))) then bindx = 4;
					if (((srindx2 < 9)&(xmint = 1))|((srindx2 < 6)&(xmint = 1))) then bindx = 3;
					if (((srindx2 < 4)&(xmint = 1))|((srindx2 < 3)&(xmint = 1))) then bindx = 2;
	                indres[mpairs+counter,1] = step2*bresmat[bindx,1];
                  	indse[counter, 3] = indse[counter, 3]*(bresmat[bindx,2]**2); 
                  	indse[counter,1:2] = indse[counter,1:2]*(bresmat[bindx,1]**2);
					if (mpairs > 2) then indse[counter, 4:(mpairs+1)] = j(1, ncol(4:(mpairs+1)), 0);
					counter = counter +1;
				end;
			end; 
			
		end;
	end;
	if (normal = 1) then;do;
      serlind=indres[(mpairs+1):(nrow(indres)-1)];
	  serialse = sqrt(indse[+,]);
      sobelZ=serlind/t(serialse);
	  sobelp=2*(probnorm(-abs(sobelZ)));
	  serindn=serlind||t(serialse)||sobelZ||sobelp;
	  normres[(mpairs+1):(mpairs+serind),]=serindn;
	end;
  end;
 
  * Total Monte Carlo;
  if (mc = 1) then;do;
  	mcind[,ncol(mcind)] = mcind[,+];
	mcsort=mcind[,ncol(mcind)];
    mcgrad=rank(mcsort);
	mcsort[mcgrad]=mcsort;
	mcllci=mcsort[lcii];mculci=mcsort[ucii];
    tempmn=mcsort[+,]/mcsamps;
    tempsm=(mcsort[,1]-tempmn)##2;semc=sqrt(tempsm[+,]/(mcsamps-1));
	mcres[nrow(mcres),]=indres[+,]||semc||mcllci||mculci;
	if ((contrast=1) & (mpairs > 1)) then;do;
      npairs = Mpairs*(Mpairs-1)/2; 
	  contres=j(npairs,4,0);
	  contsamp=j(samples,npairs,0);
	  contsort=contsamp;
	  counter=1;
	  do i = 1 to mpairs-1;
	    do j = (i+1) to mpairs;
		  contsamp[,counter]=mcind[,i]-mcind[,j];
		  contres[counter,1]=indres[i,1]-indres[j,1];
		  tttt=contsamp[,counter];
          tempmn=tttt[+,]/mcsamps;
          tempsm=(tttt[,1]-tempmn)##2;
          contres[counter,2]=sqrt(tempsm[+,]/(mcsamps-1));
          contgrad=rank(tttt);
		  contsort[contgrad,counter]=tttt;
          contres[counter,3]=contsort[lcii,counter];
		  contres[counter,4]=contsort[ucii,counter];
		  counter=counter+1;
		end;
	  end;
	end;
  end;

  * Bootstrapping;
  badboot = 0;
  if (mc ^= 1) then;do;
  	*Check the determinant for however many models there are;
	detcheck = j(Mpairs+2,1,-999);
	* Bootsamp contains indirect effects (1, 2, or 4 depending on moderation X Mpairs, 1 total indirect effect, serial indirect effects (if applicable);
	detsum = detcheck[+,];
    bootsamp=j(samples,mpairs*(1+(apathmod=1))*(1+(bpathmod=1))+1+serind*(serial=1),0);
	if(serial = 1) then; do;
		if (xmint = 1) then bootcol = mpairs##2 -1;
		if (xmint = 0) then bootcol = ((mpairs - 1)##2 + 3*(mpairs - 1))/2;
	end;
	if (serial = 0) then bootcol = -999;
	* Bootsave just contains path coefficients;
	if(serial=0)then totsav = nrow(aresmat)+nrow(bcpvec)+nrow(cresmat);
	if(serial = 1) then totsav = nrow(serres)+1+nrow(bcpvec)+nrow(cresmat);
	bootsave=j(samples,totsav,0);

	do i = 1 to samples;
		k = 1;
		do until (detsum=0) ;
			counterj = 1;
		    sortvar=floor((ranuni(j(n,1,&seed)))*n)+1;
	        bootdat=datat[sortvar,];
			if (xmint = 1) then; do;
			    do j = 1 to mpairs;
		          tempmn=bootdat[,2*j+(anymod=1)];tempmn=tempmn[+,]/n;
			      bootdat[,2*j+(anymod=1)]=bootdat[,2*j+(anymod=1)]-tempmn;
			    end;
			end;
			if((bpathmod=1)|(dpathmod=1)) then; do;
				btmoddat = bootdat[,1:Wcount];
				if(center>0) then; do;
					%centerd(centdat = (bootdat[,1:Wcount]));
					btmoddat = outdat;
				end;
				do l = (Wcount+1) to (ncol(bootdat)-1) by (1+xmint);
					if(bpathmod=1) then; do;
						btmoddat = btmoddat||btmoddat[,1]#bootdat[,l];
					end;
					if(dpathmod = 1) then; do;
						btmoddat = btmoddat||btmoddat[,1]#bootdat[,l+1];
					end;
				end;
			end;

			*bootdat for b-model;
		    bootdes=j(n,1,1)||bootdat[,(1+anymod):(ncol(bootdat)-1)];
			if(cppthmd=1) then bootdes = j(N,1,1)||bootdat[,1:(ncol(bootdat)-1)];
			if((bpathmod=1)|(dpathmod=1)) then bootdes = bootdes||btmoddat[,2:ncol(btmoddat)];
			testi = det(bootdes`*bootdes);
		    detcheck[1,1]=(testi=0);
			counterj = counterj+1;
			bootcdes = j(N,1,1);
			if(anymod>0) then bootcdes = bootcdes||bootdat[,1:Wcount];
			detcheck[counterj,1] = (det(bootcdes`*bootcdes)=0);
			counterj = counterj+1;
			do j = 1 to mpairs;
				bootades = j(N,1,1);
				if ((serial=1)&(j  > 1)) then; do;
					bootades = j(N,1,1)||bootdat[,1:((j-1)*(1+xmint))];
				end;
				if(apathmod=1)then;do;
					bootades = bootades||bootdat[,1:Wcount];
				end;
				detcheck[counterj,1] = (det(t(bootades)*bootades)=0);
				counterj = counterj+1;
			end;
			badboot = badboot+(k=2);
			k = k+1;
			detsum = detcheck[+,1];
		end; *do k = 1 to 10000;
	  bootbeta=inv(bootdes`*bootdes)*bootdes`*bootdat[,ncol(bootdat)];
	  bootavec = j(mpairs*(1+apathmod), 1, -999);
	  bootbvec = j(mpairs*(1+bpathmod), 1, -999);
	  bootdvec = j(mpairs*(1+dpathmod), 1, -999);
	  bootcvec = j(2-(anymod=0), 1, -999);
	  bootcpvec = bootbeta[1:(1+cppthmd), 1];
	  if (serial = 1) then bootser = j(bootcol,1,-999);
	  start = 1;
	  counterj = 1;

	  *Total effect bootstrap model;
	  bootcdes = j(N,1,1);
	  if(anymod>0) then bootcdes = bootcdes||bootdat[,1:Wcount];
	  bootcvec = inv(t(bootcdes)*bootcdes)*t(bootcdes)*bootdat[,ncol(bootdat)];

	  *a-path bootstrap model;
	  do j = 1 to Mpairs;
	  	bootades = j(N,1,1);
		if(apathmod=1) then bootades = bootades||bootdat[,1:Wcount];
		colj = (1+xmint)*j+Wcount-xmint;
		rowj = j*(1+aWcount)-aWcount;
        bootavec[rowj:(rowj+aWcount),1]=inv(bootades`*bootades)*bootades`*bootdat[,colj];
		bootbvec[j,1] = bootbeta[2+cppthmd+(j-1)*(1+xmint), 1];
		if(xmint=1) then; do;
			bootdvec[j,1] = bootbeta[3+cppthmd+(j-1)*(1+xmint), 1];
			if(dpathmod = 1) then; do;
				bootdvec[j+mpairs,1] = bootbeta[2+bpathmod+mpairs*(1+xmint)+cppthmd+(j-1)*(bpathmod+xmint), 1]; 
			end;
		end;
		if(bpathmod=1) then bootbvec[j+mpairs,1] = bootbeta[2+mpairs*(1+xmint)+cppthmd+(j-1)*(1+dpathmod),1];
		bootb = bootbvec[j,1];
		if(bpathmod = 1) then bootb = bootb||bootbvec[j+mpairs,1];
        if ((serial=1) & (j > 1)) then;do;
		  bootades = j(N,1,1)||bootdat[,1:((j-1)*(1+xmint))];
		  if (xmint = 1) then end = j##2 - 1;
		  if (xmint = 0) then end = ((j-1)##2 + 3*(j-1))/2;
		  bootser[start:end,1] = inv(bootades`*bootades)*bootades`*bootdat[,((j-1)*(1+xmint)+1)];
		  bootavec[counterj,1] = bootser[start,1];
		  start = end + 1;
	    end; *if ((serial=1) & (j > 1));
		aindx =  (j*(2-(apathmod = 0))-(apathmod=1));
		amat = bootavec[aindx:(aindx+(apathmod = 1))];
		indmat = t(bootb)*t(amat);
		indvec = shape(indmat, 1, (1+(apathmod=1))*(1+(bpathmod=1)));
	    bootsamp[i,counterj:(counterj-1+(1+(apathmod=1))*(1+(bpathmod=1)))]=indvec;
		counterj = counterj+(1+(apathmod=1))*(1+(bpathmod=1));
	  end; *do j = 1 to Mpairs;

	  *serial loop;
	if(serial = 1) then; do;
		counter = 1;
		do j = 1 to (mpairs - 1);
			do m = 1 to (mpairs - j);
				step1 = bootavec[m,1];
				do l = m to (mpairs - j);
					if (xmint = 1) then srindx2 = (l##2 -1)+2*m;
					if (xmint = 0) then srindx2 = l*(l+1)/2 + m;
					step2 = step1*bootser[srindx2,1];
					if (j > 1) then; do;
						do h = (l+1) to (mpairs-j+1);
							if (xmint = 1) then srindx3 = h##2 - 1 + 2*(l+1);
							if (xmint = 0) then srindx3 = h*(h+1)/2 + l + 1;
							step3 = step2*bootser[srindx3,1];
							if (j > 2) then; do;
								do o = (h+1) to (mpairs-j+2);
									if (xmint = 1) then srindx4 = o##2 - 1 + 2*(h+1);
									if (xmint = 0) then srindx4 = o*(o+1)/2 + h + 1;
									step4 = step3*bootser[srindx4,1];
									if (j > 3) then; do;
										if (xmint = 1) then srindx5 = 23;
										if (xmint = 0) then srindx5 = 14;
										step5 = step3*bootser[srindx5,1];
										bootsamp[i,mpairs+counter] = step5*bootbvec[5,1];
										counter = counter +1;
									end;
									else do;
										bindx = 5;
										if (((srindx4 < 16)&(xmint = 1))|((srindx4 < 10)&(xmint = 1))) then bindx = 4;
										if (((srindx4 < 9)&(xmint = 1))|((srindx4 < 6)&(xmint = 1))) then bindx = 3;
										if (((srindx4 < 4)&(xmint = 1))|((srindx4 < 3)&(xmint = 1))) then bindx = 2;
										bootsamp[i, mpairs + counter] = step4*bootbvec[bindx,1];
										counter = counter + 1;
									end; *elseif;
								end; *oloop;
							end;
							else do;
								bindx = 5;
								if (((srindx3 < 16)&(xmint = 1))|((srindx3 < 10)&(xmint = 1))) then bindx = 4;
								if (((srindx3 < 9)&(xmint = 1))|((srindx3 < 6)&(xmint = 1))) then bindx = 3;
								if (((srindx3 < 4)&(xmint = 1))|((srindx3 < 3)&(xmint = 1))) then bindx = 2;
								bootsamp[i, mpairs + counter] = step3*bootbvec[bindx,1];
								counter = counter + 1;
							end; *else (j > 2);
						end; *hloop;
					end; *(j > 1);
					else do;
						bindx = 5;
						if (((srindx2 < 16)&(xmint = 1))|((srindx2 < 10)&(xmint = 1))) then bindx = 4;
						if (((srindx2 < 9)&(xmint = 1))|((srindx2 < 6)&(xmint = 1))) then bindx = 3;
						if (((srindx2 < 4)&(xmint = 1))|((srindx2 < 3)&(xmint = 1))) then bindx = 2;
						bootsamp[i, mpairs + counter] = step2*bootbvec[bindx,1];
						counter = counter + 1;
					end; *elseif ( j > 1);
				end; *lloop;
			end; *mloop;
		end; *jloop;
	end; *serialif;
	
	*save bootstrap estimates;
	if((serial=0)&(xmint=1)) then; do;
		bootsave[i,] = t(bootcvec)||t(bootavec)||t(bootcpvec)||t(bootbvec)||t(bootdvec);
	end;
	if((serial=0)&(xmint=0)) then; do;
		bootsave[i,] = t(bootcvec)||t(bootavec)||t(bootcpvec)||t(bootbvec);
	end;
	if((serial=1)&(xmint=1)) then; do;
		bootsave[i,] = t(bootcvec)||t(bootavec[1,1])||t(bootser)||t(bootcpvec)||t(bootbvec)||t(bootdvec);
	end;
	if((serial=1)&(xmint=0)) then; do;
		bootsave[i,] = t(bootcvec)||t(bootavec[1,1])||t(bootser)||t(bootcpvec)||t(bootbvec);
	end;
	
 end; *iloop;

if (badboot>0)then runnotes[14,1] = 14;

    if ((contrast = 1) & (mpairs > 1)) then;do;
      npairs = (ncol(bootsamp)-1)*(ncol(bootsamp)-2)/2;
	  contres=j(npairs,4,0);
	  contsamp=j(samples,npairs,0);
	  counter=1;
	  do i = 1 to (ncol(bootsamp)-2);
	    do j = i+1 to (ncol(bootsamp)-1);
		contsamp[,counter]=bootsamp[,i]-bootsamp[,j];
		contres[counter,1]=indres[i,1]-indres[j,1];
		counter=counter+1;
		end;
	  end;
	end;
	tempsm=bootsamp[,1:(ncol(bootsamp)-1)];
    bootsamp[,ncol(bootsamp)]=tempsm[,+];
	indres[nrow(indres),1]=indres[+,];

	bootsort=bootsamp;
	seboots=j(nrow(indres),1,0);
	bccires=j(4,ncol(bootsamp),0);
	bootllci=j(1,ncol(bootsamp),0);
	bootulci=j(1,ncol(bootsamp),0);
    zalpha2=sqrt(-2*log(alpha/2));
    zalpha2=(zalpha2+((((zalpha2*p4+p3)*zalpha2+p2)*zalpha2+p1)*zalpha2+p0)/((((zalpha2*q4+q3)*zalpha2+q2)*zalpha2+q1)*zalpha2+q0));
	do i = 1 to ncol(bootsamp); 
	  if (bc = 1) then estbc = indres[i,1];
	  if (bc = 0) then estbc = -9999;
	  %bcbootM(dat = (bootsamp[,i]), est = estbc);
      tempmn=bootsamp[+,i]/samples;
      tempsm=(bootsamp[,i]-tempmn)##2;
      seboots[i,1]=sqrt(tempsm[+,]/(samples-1));
	  bootllci[1,i]=llcit;
      bootulci[1,i]=ulcit;
	end; *do i = 1 to ncol(bootsamp); 
	bootci=bootllci`||bootulci`;
	bootres=indres||seboots||bootci;
 
  if ((contrast = 1) & (mpairs > 1)) then; do; *2;
  	bccicont=j(4,ncol(contsamp),0);
	contsort=contsamp;
	contllci=j(1,ncol(contsamp),0);
	contulci=j(1,ncol(contsamp),0);
    do i = 1 to ncol(contsamp);
	  if (bc = 1) then estbc = contres[i,1];
	  if (bc = 0) then estbc = -9999;
	  %bcbootM(dat = (contsamp[,i]), est = estbc);
      tempmn=contsamp[+,i]/samples;
      tempsm=(contsamp[,i]-tempmn)##2;
	  contres[i,2]=sqrt(tempsm[+,]/(samples-1));
	  contllci[1,i]=llcit;
      contulci[1,i]=ulcit;
	end; *close do i = 1 to ncol(contsamp);
	contci=t(contllci)||t(contulci);
	contres[,3:4]=contci;
  end; *2; *if ((contrast = 1) & (mpairs > 1));
  end; *if (mc ^= 1);
 end; *3; *Close not 2 and not 3;

if ((((model = 2)|(model = 3))|(anymod > 0))&(criterr = 0))then; do;
	%dichot(modcount = Wcount, dat = moddat);
	if((quantile=0)|(plot=1)) then; do;
		modmeans = moddat[+,1:wcount]/N;
		dmeans = diag(modmeans);
		meansmat = j(N, Wcount,1)*dmeans;
		tempmddat = moddat[,1:Wcount]-meansmat; 
		tempmddat = tempmddat##2;
		modsds = sqrt((tempmddat[+,])/(N-1));
		dimmc = 3##(Wcount - dich[+,1])*(2##dich[+,1]);
		modcomb = j(dimmc, Wcount, -999);
		counter = 1;
		last = dimmc;
		do i = 1 to Wcount;
			if(dich[i,1] = 0)then;do;
				do j = 1 to counter;
					modcomb[(last*(j-1)+1):(last*j),i] = j(last/3, 1, modmeans[1,i]-modsds[1,i])//j(last/3, 1, modmeans[1,i])//j(last/3, 1, modmeans[1,i]+modsds[1,i]);
				end;*do j = 1 to counter;
				last = last/3;
				counter = counter*3;
			end; *if(dich[i,1] = 0);
			if(dich[i,1] ^= 0) then; do;
				do j = 1 to counter;
					modcomb[(last*(j-1)+1):(last*j),i] = j(last/2, 1, dich[i,2])//j(last/2, 1, dich[i,3]);
				end; *do j = 1 to counter;
				last = last/2;
				counter = counter*2;
			end; *if(dich[i,1] ^= 0);
		end; *do i = 1 to Wcount;
		plotdat = modcomb;
	end; *if((quantile=0)|(plot=1));

	if(quantile = 1)then; do;
		perctls = {.10, .25, .50, .75, .90};
		pctindx = round(perctls*N);
		if (pctindx[1,1] < 1) then pctindx[1,1] = 1;
		if (pctindx[1,5] > N) then pctindx[1,5] = N; 
		modtemp = data[,1:wcount];
		modsort = J(N, wcount, -999);
		do i = 1 to wcount;
		      modgrad=rank(modtemp[,i]);
		      modsort[modgrad,i]=moddat[,i];
		end; *do i = 1 to wcount;
		pctnum = modsort[pctindx,];
		dimmc = 5##(wcount - dich[+,1])*2##(dich[+,1]);
		modcomb = J(dimmc, wcount, -999);
		counter = 1;
		last = dimmc;
		do i = 1 to wcount;
			if (dich[i,1] = 0) then; do;
				do j = 1 to counter;
					modcomb[(last*(j-1)+1):(last*j),i] = J(last/5, 1, pctnum[1,i]) // J(last/5,1,pctnum[2,i]) // J(last/5, 1, pctnum[3,i]) // J(last/5, 1, pctnum[4,i]) // J(last/5, 1, pctnum[5,i]);
				end; *do j = 1;
			last = last/5;
			counter = counter*5;
			end; *if (dich[i,1] = 0);
			if (dich[i,1] = 1) then; do;
				do j = 1 to counter;
					modcomb[(last*(j-1)+1):(last*j),i] = J(last/2, 1, dich[i,2]) // J(last/2,1,dich[i,3]);
				end;
			last = last/2;
			counter = counter*2;
			end; *if (dich[i,1] = 1);
		end; *do i = 1;
		plotdat = modcomb;
	end; *if(quantile = 1);
end; *if ((((model = 2)|(model = 3))|(anymod > 0))&(criterr = 0));

*Probe conditional effect of X on Y;
*V3: with multiple moderators, will need to account for interactions;
if(anymod > 0 ) then; do;
	%probres(coef = cvec, values = modcomb, semat = sem4cmat, df = m4df2);
	XYgWres = pbresmat;
	if (setswv > 0) then; do;
		%probres(coef = cvec, values = modvmat, semat = sem4cmat, df = m4df2);
		XYgWvres = pbresmat;
	end;
	if(quantile = 0) then; do;
		plotdat = XYgWres[,1:(Wcount+1)];
		if(apathmod = 1) then; do;
			plotdat = plotdat || j(nrow(XYgWres), Mpairs, -999);
		end; *if(apathmod = 1);
		plotdes = modcomb;
		plotdes = j(nrow(plotdes), 1, 1) || plotdes;
	end; *if(quantile = 0);
	if (quantile ^=0) then; do;
		plotdes = plotdat;
		plotdes = j(nrow(plotdes),1,1)||plotdes;
		plotdat = plotdat||j(nrow(plotdat),1+apathmod*mpairs, -999);
		plotdat[,Wcount+1] = plotdes*cvec;
	end; *if (quantile ^=0);

	if (jn = 1) then; do;
		%JNprobe(coefOne = (cvec[1,1]), coefTwo = (cvec[2,1]), seOne = (sem4cmat[1,1]), seTwo = (sem4cmat[2,2]), cov = (sem4cmat[2,1]), critt = tcritc, dfJN = m4df2);
		cNumJN = NumJN;
		cJNres = JNres;
		if(NumJN>0)then;do;
			cJNsoln = t(JNSoln);
			cPcntabv = Pcntabv;
		end; *if(NumJN>0);
	end; *if (jn = 1);
end; *if(anymod > 0 );

if(apathmod=1) then; do;
	XMgWres = j(dimmc*mpairs, Wcount+6, -999);
	if (setswv > 0) then; do;
		XMgWvres = j(setswv*mpairs, Wcount+6, -999);
	end; *if (setswv > 0);
	if(jn=1) then; do;
		aJNres = j(22*mpairs, 7, -999);
		aJNsoln = j(mpairs, 2, -999);
		aPcntabv = j(mpairs, 2, -999);
		aNumJN = j(mpairs, 1, -999);
	end; *if(jn=1);
	do j = 1 to Mpairs;
		rowj = j*(1+Wcount)-Wcount;
		avec = aresmat[rowj:(rowj+Wcount),1];
		ase = sem3aall[rowj:(rowj+Wcount),];
		*V3: for serial mediation need a vector of degrees of freedom;
		%probres(coef=avec,values=modcomb,semat=ase,df=m3df2);
		XMgWres[(j*dimmc-(dimmc-1)):(j*dimmc),]=pbresmat;
		if(setswv>0) then;do;
			%probres(coef=avec,values=modvmet,semat=ase,df=m3df2);
			XMgWvres[(j*setswv-(setswv-1)):(j*setswv),] = pbresmat;
		end; *if(setswv>0);
		if(quantile=0)then;do;
			plotdat[,Wcount+1+j] = XMgWres[(j*dimmc-(dimmc-1)):(j*dimmc),2];
		end; *if(quantile=0);
		if(quantile^=0)then;do;
			plotddat[,Wcount+1+j] = plotdes*avec;
		end; *if(quantile^=0);
		if (jn=1) then; do;
			%JNprobe(coefOne = (avec[1,1]), coefTwo = (avec[2,1]), seOne = (ase[1,1]), seTwo = (ase[2,2]), cov = (ase[2,1]), critt = tcrita, dfJN = m3df2);
			aNumJN[j,] = NumJN;
			aJNres[(1+22*(j-1)):(20+NumJN+22*(j-1)),] = JNres;
			if(NumJN>0)then;do;	
				aJNsoln[j,1:NumJN] = t(JNSoln);
				aPcntabv[j,1:NumJN] = Pcntabv;
			end; *if(NumJN>0);
		end; *if (jn=1);
	end; *do j = 1 to Mpairs;
end; *if(apathmod=1);

if(bpathmod=1)then;do;
	*probe conditional effect of M on Y;
	MYgWres = j(dimmc*mpairs, Wcount+6, -999);
	if(setswv > 0)then;do;
		MYgWvres = j(setswv*mpairs, Wcount+6, -999);
	end; *if(setswv > 0);
	bplotdat = j(dimmc*3*mpairs, 3, -999);
	if(jn=1) then; do;
		bJNres = j(22*mpairs, 7, -999);
		bJNsoln = j(mpairs, 2, -999);
		bPcntabv = j(mpairs, 2, -999);
		bNumJN = j(mpairs, 1, -999);
	end; *if(jn=1);
	do j = 1 to Mpairs;
		bvec = bresmat[j,1]//bresmat[j+mpairs,1];
		firstloc = 2+cppthmd+(j-1)*(1+xmint);
		secloc = 2+cppthmd+mpairs*(xmint+1)+(j-1)*(1-dpathmod);
		bse = (sebcpmat[firstloc, firstloc] || sebcpmat[firstloc,secloc])//(sebcpmat[firstloc,secloc]||sebcpmat[secloc,secloc]);
		%probres(coef = bvec, values = modcomb, semat = bse, df = df2);
		MYgWres[(j*dimmc-(dimmc-1)):(j*dimmc),] = pbresmat;
		if(setswv > 0) then; do;
			%probres(coef = bvec, values = modvmat, semat = bse, df = df2);
			MYgWvres[(j*setswv-(setswv-1)):(j*setswv),] = pbresmat;
		end; *if(setswv > 0);
		bpvec = bcpvec[1:(1+cppthmd),1]//bvec;
		Mdmean = dataT[+,Wcount+j+(j-1)*xmint]/N;
		tempmd = dataT[,Wcount+j+(j-1)*xmint]-Mdmean; 
		tempmd = tempmd##2;
		Mdsd = sqrt((tempmd[+,])/(N-1));
		Mdvec = (Mdmean-Mdsd)//Mdmean // (Mdmean+Mdsd);
		longW = j(3,1,plotdes[1,2]);
		Mdvecrep = Mdvec;
		do k = 2 to dimmc;
			longW = longW//j(3,1,plotdes[k,2]);
			Mdvecrep = Mdvecrep // Mdvec;
		end; *do k = 2 to dimmc;
		bplotdes = j(dimmc*3, 1, 1);
		if(cppthmd=1)then;do;
			bplotdes = bplotdes||longW;
		end; *if(cpthmd=1);
		bplotdes = bplotdes||Mdvecrep;
		bplotdes = bplotdes||(Mdvecrep#longW);
		bplotdat[(1+(j-1)*dimmc*3):(j*dimmc*3),] = longW||mdvecrep||(bplotdes*bpvec);
		if(jn=1)then;do;
			%JNprobe(coefOne = (bvec[1,1]), coefTwo = (bvec[2,1]), seOne = (bse[1,1]), seTwo = (bse[2,2]), cov = (bse[2,1]), critt = tcritb, dfJN = df2);
			bNumJN[j,] = NumJN;
			bJNres[(1+22*(j-1)):(20+bNumJN[j,]+22*(j-1)),] = JNres;
			if(bNumJN[j,]>0)then;do;
				bJNsoln[j,1:(bNumJN[j,])] = t(JNSoln);
				bPcntabv[j,1:(bNumJN[j,])] = Pcntabv;
			end; *if(bNumJN[j,]>0);
		end;*if(jn=1);
	end; *do j = 1 to Mpairs;
end; *if(bpathmod=1);

if(cppthmd = 1) then; do;
	if(xmint=1) then; do;
		modcomb2 = modcomb;
		if(setswv > 0) then; do;
			modcomb2 = modcomb//modvmet;
		end; *if(setswv > 0);
		modcmbcp = modcomb||j(dimmc+setswv, mpairs*(1+dpathmod), -999);
		cpvec = cpresmat[,1]//j(mpairs*(1+dpathmod),1,-999);
		locindx = j(mpairs*(1+dpathmod),1,-999);
		do j = 1 to mpairs;
			mmoddes = j(N,1,1)||moddat[,1:Wcount];
			locindx[j,1] = 1+cppthmd+j*2;
			mmodvec = inv(t(mmoddes)*mmoddes)*t(mmoddes)*bcpdes[,locindx[j,1]];
			mapred = mmoddes*mmodvec;
			ssr = (bcpdes[,locindx[j,1]]-mapred)##2;
			ssr = ssr[+,];
			tempmn = bcpdes[,locindx[j,1]];
			tempmn = tempmn[+,]/N;
			sst = (bcpdes[,locindx[j,1]]-tempmn)##2; sst = sst[+,];
			msr = ssr/(n-ncol(mmoddes));
			mmoddf2 = N-ncol(mmoddes);
			semmodmt = (msr*inv(t(mmoddes)*mmoddes));
			%probres(coef = mmodvec, values = modcomb2, semat = semmodmt, df = mmoddf2);
			modcmbcp[,Wcount+j] = pbresmat[,1+Wcount];
			cpvec[2+j,1] = bcpvec[locindx[j,1],1];
			if(dpathmod = 1)then; do;
				locindx[j+mpairs,1] = 2+cppthmd+mpairs*(xmint+1)+(j-1)*(1+bpathmod)+bpathmod;
				cpvec[2+j+mpairs,1] = bcpvec[locindx[j+mpairs,1],1];
				modcmbcp[,Wcount+mpairs+j] = modcmbcp[,1]#modcmbcp[,Wcount+j];
			end; *if(dpathmod = 1);	
		end; *do j = 1 to mpairs;
		locindx = t(1:(1+Wcount))//locindx;
		cpse = sebcpmat[locindx, locindx];
	end; *if(xmint=1);
	if(xmint = 0) then;do;
		cpvec = cpresmat[,1];
		cpse = sebcpmat[1:(1+Wcount), 1:(1+Wcount)];
		modcomb2 = modcomb;
		if(setswv >0) then; do;
			modcomb2 = modcomb//modvmat;
		end; *if(setswv >0);
		modcmbcp = modcomb2;
	end;*if(xmint = 0);
	%probres(coef = cpvec, values = modcmbcp, semat = cpse, df = df2);
	if(xmint = 1) then; do;
		XYgWcMrs = pbresmat[,1:(Wcount+Mpairs)]||pbresmat[,(ncol(modcmbcp)+1):ncol(pbresmat)];
	end; *if(xmint = 1);
	if(xmint = 0) then; do;
		XYgWcMrs = pbresmat;
	end; *if(xmint=0);
	if(setswv>0) then; do;
		XYgWcMv = XYgWcMrs[(dimmc+1):(dimmc+setswv),];
		XYgWcMrs = XYgWcMrs[1:dimmc,];
	end; *if(setswv>0);
	cppltdat = XYgWcMrs[,1]||XYgWcMrs[,2+Mpairs*xmint];
	if(jn=1) then; do;
		%jnprobe(coefOne = (cpvec[1,1]), coefTwo = (cpvec[2,1]), seOne = (cpse[1,1]), seTwo = (cpse[2,2]), cov = (cpse[2,1]), critt = tcritcp, dfJN = df2);
		cpnumJN = numJN;
		cpJNres = JNres;
		if(cpnumJN>0)then;do;
			cpJNsoln = JNsoln;
			cpPcntabv = Pcntabv;
		end; *if(cpnumJN>0);
	end; *if(jn=1);
end; *if(cppthmd = 1);

if(dpathmod = 1) then; do;
	MAYgWres = j(dimmc*mpairs, Wcount+6, -999);
	if(setswv >0) then; do;
		MAYgWvrs = j(setswv*mpairs, Wcount+6, -999);
	end; *if(setswv >0);
	dplotdat = j(dimmc*3*mpairs, 3, -999);
	if(jn=1) then; do;
		dJNres = j(22*mpairs, 7, -999);
		dJNsoln = j(mpairs, 2, -999);
		dPcntabv = j(mpairs, 2, -999);
		dNumJN = j(mpairs, 1, -999);
	end; *if(jn=1);
	do j = 1 to Mpairs;
		dvec = dresmat[j,1]//dresmat[j+mpairs,1];
		firstloc = 3+cppthmd+(j-1)*2;
		secloc = 3+cppthmd+(mpairs-1)*(xmint+1)+j*(1+bpathmod);
		dse = (sebcpmat[firstloc, firstloc]|| sebcpmat[firstloc, secloc])//(sebcpmat[secloc, firstloc]|| sebcpmat[secloc, secloc]);
		%probres(coef = dvec, values = modcomb, semat = dse, df = df2);
		MAYgWres[(j*dimmc-(dimmc-1)):(j*dimmc),] = pbresmat;
		if(setswv >0) then; do;
			%probres(coef = dvec, values = modvmat, semat = dse, df = df2);
			MAYgWvrs[(j*setswv-(setswv-1)):(j*setswv),] = pbresmat;
		end; *if(setswv >0);
		dpvec = bcpvec[1:(1+cppthmd),1]//dvec;
		MAmean = dataT[+,Wcount+j+1+(j-1)*xmint]/N;
		tempMA = dataT[,Wcount+j+1+(j-1)*xmint]-MAmean;
		tempMA = tempMA##2;
		MAsd = sqrt((tempMA[+,])/(N-1));
		MAvec = (MAmean - MAsd)// (MAmean) // (MAmean + MAsd);
		MAvecrep = MAvec;
		longW = j(3,1,plotdes[1,2]);
		do k = 2 to dimmc;
			longW = longW//j(3, 1, plotdes[k,2]);
			MAvecrep = MAvecrep//MAvec;
		end; *do k = 2 to dimmc;
		dplotdes = j(dimmc*3,1,1);
		if(cppthmd = 1) then; do;
			dplotdes = dplotdes||longW;
		end; *if(cppthmd = 1);
		dplotdes = dplotdes||MAvecrep;
		dplotdes = dplotdes||(MAvecrep#longW);
		dplotdat[(1+(j-1)*dimmc*3):(j*dimmc*3),] = longW||MAvecrep||(dplotdes*dpvec);
		if(jn=1)then;do;
			%jnprobe(coefOne = (dvec[1,1]), coefTwo = (dvec[2,1]), seOne = (dse[1,1]), seTwo = (dse[2,2]), cov = (dse[2,1]), critt = tcritd, dfJN=df2);
			dNumJN[j,] = NumJN;
			dJNres[(1+22*(j-1)):(20+dNumJN[j,]+22*(j-1)),] = JNres;
			if(dNumJN[j,] > 0)then; do;
				dJNsoln[j,1:(dNumJN[j,])] = t(JNSoln);
				dPcntabv[j,1:(dNumJN[j,])] = Pcntabv;
			end; *if(dNumJN[j,] > 0);
		end; *if(jn=1);
	end; *do j = 1 to Mpairs;
end; *if(dpathmod = 1);

*Conditional Indirect Effects;
if(((apathmod = 1)|(bpathmod=1))&(criterr=0)) then; do;
	immres = j(mpairs, 4, -999);
	cindres = j((dimmc+setswv)*mpairs, 5, -999);
	modmat = j(1, dimmc, 1)//t(modcomb);
	if(setswv>0) then; do;
		modmat = modmat|| (j(1, setswv,1)//t(modvmat));
	end; *if(setswv>0);
	cindres[,1] = shape(j(mpairs,1,1)*modmat[2,], (dimmc+setswv)*mpairs,1);
	do i = 1 to Mpairs;
		if(apathmod=1) then; do;
			if(mc=0) then asamps = bootsave[,(1+2*i):(2+2*i)];
			if(mc=1) then asamps = mcsave[,(-1+2*i):(2*i)]; 
			casamps=asamps*modmat;
			condas = XMgWres[(1+(i-1)*dimmc):(i*dimmc),2];
			if(setswv >0) then condas = condas//XMgWves[(1+(i-1)*setswv):(i*setswv),2];
		end; *if(apathmod=1);
		if(apathmod=0) then; do;
			if(mc=0) then casamps = bootsave[,2+i];
			if (mc = 1) then casamps = mcsave[,i];
			casamps = casamps*j(1,dimmc+setswv,1);
			condas = j((dimmc+setswv), 1, aresmat[i,1]);
		end; *if(apathmod=0);

		if(bpathmod=1) then; do;
			if(mc=0) then bsamps = bootsave[,3+(1+apathmod)*mpairs+cppthmd+i]||bootsave[,3+(2+apathmod)*mpairs+cppthmd+i];
			if(mc=1) then bsamps = mcsave[,(-1+(1+apathmod)*mpairs+2*i):((1+apathmod)*mpairs+2*i)];
			cbsamps = bsamps*modmat;
			condbs = MYgWres[(1+(i-1)*dimmc):(i*dimmc),2];
			if(setswv>0) then condbs = conbs // MYgWvres[(1+(i-1)*setswv):(i*setswv),2];
		end; *if(bpathmod=1);
		if(bpathmod=0) then; do;
			if(mc=0) then cbsamps = bootsave[,3+(1+apathmod)*mpairs+cppthmd+i]*j(1, dimmc+setswv, 1);
			if(mc=1) then; do;
				cbsamps = mcsave[, (1+apathmod)*mpairs+i];
				cbsamps = cbsamps*j(1, dimmc+setswv, 1);
			end;*if(mc=1);
			condbs = j((dimmc+setswv), 1, bresmat[i,1]);
		end; *if(bpathmod=0);
		cindres[(1+(i-1)*(dimmc+setswv)):(i*(dimmc+setswv)),2] = condas#condbs;
		cabsamps = casamps#cbsamps;
		scabsamps = cabsamps;
		if(dimmc = 2) then; do;
			immsamp = cabsamps[,2]- cabsamps[,1];
			immres[i,1] = condas[2,1]*condbs[2,1] - condas[1,1]*condbs[1,1];
			if (bc = 1) then estbc = immres[i,1];
	  		if (bc = 0) then estbc = -9999;
			%bcbootM(dat = immsamp, est = estbc);
      		tempmn=immsamp[+,]/samples;
      		tempsm=(immsamp-tempmn)##2;
	  		immres[i,2]=sqrt(tempsm[+,]/(samples-1));
	  		immres[i,3]=llcit;
      		immres[i,4]=ulcit;
		end; *if(dimmc = 2);
		do j = 1 to ncol(cabsamps);
			if (bc = 1) then estbc = cindres[j+(i-1)*ncol(cabsamps),2];
	  		if (bc = 0) then estbc = -9999;
			%bcbootM(dat = (cabsamps[,j]), est = estbc);
      		tempmn=cabsamps[+,j]/samples;
      		tempsm=(cabsamps[,j]-tempmn)##2;
	  		cindres[j+(i-1)*ncol(cabsamps),3]=sqrt(tempsm[+,]/(samples-1));
	  		cindres[j+(i-1)*ncol(cabsamps),4]=llcit;
      		cindres[j+(i-1)*ncol(cabsamps),5]=ulcit;
		end; *do j = 1 to ncol(cabsamps);
	end; *do i = 1 to Mpairs;
end; *if(((apathmod = 1)|(bpathmod=1))&(criterr=0));

if (((model = 2) | (model = 3))&(criterr=0)) then; do; *4;
	wnamemat = t(wnames) || J(wcount, 1, " ");
	modres = J(ncol(bcpdes), 6, -999);
	modres[,1] = bcpvec;
	modres[,2] = sebcp;
	modres[,3] = modres[,1]/modres[,2];
	modres[,4] = 2*(1-probt(abs(modres[,3]), df2));
	modres[,5:6] = (modres[,1] - tcritb*modres[,2])|| (modres[,1] + tcritb*modres[,2]);

	*Conditional effects of X on Y at values of W;
	dich = J(wcount, 3, -999);
	XYgWres = modcomb || J(dimmc, 6, -999);
	if (model = 3) then; do;
		do h = 1 to (wcount - 1);
			do i = 1 to (wcount - h);
				rchoosek = comb(wcount-i, h);
				tempcnt = intcount[1:h,1];
				do j = (tempcnt[+,1] - rchoosek + 1) to (tempcnt[+,1]);
					modcomb = modcomb || (modcomb[,i]#modcomb[,j]);
					if (setswv > 0) then modvmat = modvmat || modvmat[,i]#modvmat[,j];
				end;
			end;
		end;
	end;
	%probres(coef = bcpvec, values = modcomb, semat = sebcpmat, df = df2);
	XYgWres = pbresmat;
	if (setswv > 0) then; do;
		wvres = J(setswv, wcount+6, -999);
		wvres[,1:wcount] = modvmat[,1:wcount];
		modvmat = J(setswv, 1, 1) || modvmat;
		wvres[,wcount+1] = modvmat*bcpvec;
		wvres[,wcount+2] = sqrt(vecdiag(modvmat*sebcpmat*t(modvmat)));
		wvres[,wcount+3] = wvres[,wcount+1]/wvres[,wcount+2];
		wvres[,wcount+4] = 2*(1-probt(abs(wvres[,wcount+3]), df2));
		wvres[,(wcount+5):(wcount+6)] = wvres[,wcount+1]-tcritb*wvres[,wcount+2]|| wvres[,wcount+1]+tcritb*wvres[,wcount+2];
	end;

	if ((dich[+,1] > 0) & (jn = 1)) then; do;
		jn = 0;
		runnotes[17,1] = 17;
	end;

	if (jn = 1) then; do;
		cquad = (bcpvec[1,1]##2)-(tcritb##2)*sebcpmat[1,1];
		bquad = 2*bcpvec[1,1]*bcpvec[2,1] - 2*(tcritb##2)*sebcpmat[1,2];
		aquad = (bcpvec[2,1]##2) - (tcritb##2)*sebcpmat[2,2];
		if ((bquad##2 - 4*cquad*aquad) >= 0) then; do;
			JNsoln = ((-1*bquad + sqrt(bquad##2 - 4*cquad*aquad))/(2*aquad))//((-1*bquad - sqrt(bquad##2 - 4*cquad*aquad))/(2*aquad));
			solngrad = rank(JNsoln);
			JNsoln[solngrad,1] = JNsoln[,1];
			pcntabv = ((moddat || moddat) - (J(N,2,1)*diag(JNsoln))>0);
			pcntabv = pcntabv[+,]/N*100;
			toolow = (pcntabv = 100);
			toohigh = (pcntabv = 0);
			numJN = 2-toohigh[,+]-toolow[,+];
			if (toolow[,+] = 1) then; do;
				JNsoln = JNsoln[2,1];
				pcntabv = pcntabv[2];
			end;
			if (toohigh[,+] = 1) then; do;
				JNsoln = JNsoln[1,1];
				pcntabv = pcntabv[1];
			end;
		end;
		if ((bquad##2 - 4*cquad*aquad) < 0) then; do;
			numJN = 0;
		end;
		if (numJN > 0) then; do;
			JNWcomb = J(20+numJN, 2, 1);
			minw = min(moddat);
			maxw = max(moddat);
			range = maxw - minw;
			do i = 1 to 20;
				JNWcomb[i,2] = minw + range/19*(i-1);
			end;
			if (numJN = 1) then JNWcomb[21,2] = JNsoln;
			if (numJN = 2) then JNWcomb[21:22,2] = JNsoln;
			JNgrad = rank(JNWcomb[,2]);
			JNWcomb[JNgrad,2] = JNWcomb[,2];
			JNres = JNWcomb[,2] || J(nrow(JNWcomb), 6, -999);
			JNres[,2] = JNWcomb*bcpvec;
			JNres[,3] = sqrt(vecdiag(JNWcomb*sebcpmat*t(JNWcomb)));
			JNres[,4] = JNres[,2]/JNres[,3];
			JNres[,5] = 2*(1-probt(abs(JNres[,4]), df2));
			JNres[,6:7] = (JNres[,2] - tcritb*JNres[,3]) || (JNres[,2] + tcritb*JNres[,3]);
		end;
	end;

*Probing Effects of Ws on Y;
prbmsum = J(2,7,-999);
prbmdres = J(2*ncol(bcpdes), 6, -999);
do i = 1 to 2;
	probevec = inv(t(bcpdes)*bcpdes)*t(bcpdes)*data[,(ncol(data)-2 + i)];
	prbypred = bcpdes*probevec;
	probessr = sum((data[,(ncol(data)-2 + i)] - prbypred)##2);
	probesst = sum((data[,(ncol(data)-2 + i)] - sum(data[,(ncol(data)-2 + i)])/N)##2);
	probemsr = probessr/(N-ncol(bcpdes));
	prsqfull = 1 - probessr/probesst;
	prbrfull = sqrt(prsqfull);
	probedf1 = (ncol(bcpdes) - 1);
	probedf2 = (N - ncol(bcpdes));
	prbFfull = probedf2*prsqfull/(probedf1*(1-prsqfull));
	prbpfull = 1 - probf(prbffull, probedf1, probedf2);
	seprbmat = probemsr*inv(t(bcpdes)*bcpdes);
	seprb = (vecdiag(seprbmat))##(1/2);
	prbmsum[i,] = prbrfull || prsqfull || probemsr || prbFfull || probedf1 || probedf2 || prbpfull;

	prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),1] = probevec;
	prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),2] = seprb;
	prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),3] = prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),1]/prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),2];
	prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),4] = 2*(1-probt(abs(prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),3]), df2));
	prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),5:6] = (prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),1] - tcritb*prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),2]) || (prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),1] + tcritb*prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),2]); 
end;

if (plot = 1) then; do;
	if (quantile = 0) then; do;
		plotdat = XYgWres[,1:(wcount+1)] || J(nrow(XYgWres), 2, -999);
		plotdes = modcomb;
		plotdes = j(nrow(plotdes),1,1)||plotdes;
	end;
	if (quantile = 1) then; do;
		plotdes = plotdat;
		plotdat = plotdat || J(nrow(plotdat), 3, -999);
		if (model = 3) then; do;
			do h = 1 to (Wcount - 1);
				do i = 1 to (wcount - h);
					rchoosek = comb(wcount-i, h);
					tempcnt = intcount[1:h, 1];
					do j = (tempcnt[+,] - rchoosek + 1) to (tempcnt[+,]);
						plotdes = plotdes || plotdes[,i]#plotdes[,j];
					end;
				end;
			end;
		end; *if (model = 3);
		plotdes = J(nrow(plotdes), 1, 1) || plotdes;
		plotdat[,(wcount+1)] = plotdes*bcpvec;
	end; *if (quantile = 1);

	*plot of Y for each condition by Ms;
	plotdat[,wcount+2] = plotdes*prbmdres[1:ncol(bcpdes),1];
	plotdat[,wcount+3] = plotdes*prbmdres[(ncol(bcpdes)+1):(2*ncol(bcpdes)),1];
end;

end; *4; 
	
end; *1;

print "************************ MEMORE Procedure for SAS Version 3.0 *************************";
print "Written by Amanda K. Montoya and Andrew F. Hayes";
print "Documentation available at github.com/akmontoya/MEMORE";


print "*************************** ANALYSIS NOTES AND WARNINGS ******************************";
print "Check SAS log for errors.  Do not interpret output if errors are found. Contact akmontoya@ucla.edu if errors persist.";
do i = 1 to nrow(runnotes);
  if (runnotes[i,1]=1) then;do;
    print missing [label="NOTE: Some cases were deleted due to missing data.  The number of cases was:"];
  end;
  if (runnotes[i,1]=2) then;do;
    print "ERROR: Exactly two Y variables must be provided in the Y= list.";
  end;
  if (runnotes[i,1]=3) then;do;
    print samples [label="NOTE: An invalid number of samples was specified.  The number of samples used was:"];
  end;
  if (runnotes[i,1]=4) then;do;
    print "ERROR: The number of samples specified is insufficient for desired confidence.";
	print "Please increase the number of samples or decrease confidence.";
	tttt=conf||samples;
	print tttt [label="Confidence and samples specified:"];
  end;
  if (runnotes[i,1]=5) then;do;
    print "NOTE: The confidence specified was not between 50 and 99.99.  Level of confidence";
	print "was adjusted to 95%.";
  end;
  if (runnotes[i,1]=6) then;do;
    print "ERROR: An even number of variables is required in the M= list. No more than 20 variables are allowed in the M= list.";
  end;
  if (runnotes[i,1]=7) then;do;
    print copyname [label = "ERROR: Two of the specified variables are copies.  The variable names are:"];
  end;
  if (runnotes[i,1]=8) then;do;
    print "ERROR: All specified variables must be unique. No variables may be the same in W, M, and Y.";
  end;
  if (runnotes[i,1]=9) then;do;
    print "ERROR: At least one and no more than one W variable can be specified in the W= list for Model 4 - 18.";
  end;
  if (runnotes[i,1]=10) then;do;
    print "NOTE: Contrast cannot be constructed with only one pair of mediators.";
  end;
  if (runnotes[i,1]=12) then;do;
    print "NOTE: Monte Carlo confidence intervals are not available for serial mediation";
  end;
  if (runnotes[i,1]=13) then;do;
    print "NOTE: The serial mediation model must have between 2 and 5 pairs of mediators.";
  end;
  if (runnotes[i,1]=14) then;do;
    print badboot [label = "NOTE: Some bootstrap samples had to be replaced. The number of such replacements was:"];
  end;
  if (runnotes[i,1]=15) then;do;
    print "ERROR: At least one W variable and no more than five W variables can be specified in the W list for Models 2 and 3.";
  end;
  if (runnotes[i,1]=16) then;do;
    print "ERROR: Johnson-Neyman procedure not available for models with more than one moderator.";
  end;
  if (runnotes[i,1]=17) then;do;
    print "ERROR: Johnson-Neyman procedure not available for models with a dichotomous moderator.";
  end;
  if (runnotes[i,1]=18) then;do;
    print "ERROR: You must specify a value to probe at for each moderator in the W= list. Wmodval lists should be the same length as W= list.";
  end;
  if (runnotes[i,1]=19) then;do;
    print "ERROR: Sample size is not large enough. Model is unidentified.";
  end;
  if (runnotes[i,1] = 20) then; do;
  	print "ERROR: Contrasts not available for serial mediation with more than 3 pairs of mediators.";
  end;
  if (runnotes[i,1] = 21) then; do;
  	print "ERROR: Models 2 - 18 require a variable name in the W argument.";
  end;
  if (runnotes[i,1] = 22) then; do;
  	print "ERROR: Model 1 and 4 - 18 require at least two variable names in the M argument.";
  end;
  if (runnotes[i,1] = 23) then; do;
  	print "ERROR: Invalid model number. Valid models are numbered 1 through 18. Please see documentation for model descriptions.";
  end;
  if (runnotes[i,1] = 24) then; do;
  	print "NOTE: Centering command has no effect for Model 1.";
  end;
  if (runnotes[i,1] = 25) then; do;
  	print "NOTE: Moderated mediation and serial option not available together. Parallel model estimated.";
  end;
  if (runnotes[i,1] = 26) then; do;
  	print "ERROR: Contrasts not available for models with moderated indirect effects.";
  end;
  if (runnotes[i,1] = 27) then; do;
  	print "ERROR: Model 17 only involves moderation of the XM interaction, xmint cannot be set to zero for the model. Try Model = 1, xmint = 0 for a model with no moderation and no XM interaction.";
  end;
  if (runnotes[i,1] = 28) then; do;
  	print "ERROR: Invalid entry for Center option. Please select 0 (no centering), 1 (all moderators centered, or 2 (only continuous moderators centered). No centering conducted in analysis above.";
  end;
  if (runnotes[i,1] = 29) then; do;
  	print "ERROR: Non-invertible design matrix. Results not produced. Check that variables have non-zero variance and are not perfectly correlated with each other.";
  end;
  if (runnotes[i,1] = 30) then; do;
  	print "NOTE: Plotting option only available for models with moderators. No plots generated.";
  end;
  if (runnotes[i,1] = 31) then; do;
  	print "NOTE: Both Monte Carlo Confidence Interval and Bias-Correction Bootstrap Confidence Interval were selected. Monte Carlo CI was calculated.";
  end;
  if (runnotes[i,1] = 32) then; do;
  	print "ERROR: xmint = 0 was specified for a model which moderates the XM interaction. Either change xmint settings or select a different model number.";
  end;
end;


if (criterr=0) then;do;*9;
if ((model = 1)|(model > 3)) then; do; *10;
  if ((mc ^= 1) & (bc = 1)) then;do;
    print "Bootstrap confidence interval method: Bias corrected";
  end;
  if ((mc ^= 1) & (bc ^= 1)) then;do;
    print "Bootstrap confidence interval method: Percentile";
  end;
  if (mc = 1) then;do;
    print samples [label="Number of samples for Monte Carlo confidence intervals:"];
  end;
  if (mc ^= 1) then;do;
    print samples [label="Number of samples for bootstrap confidence intervals:"];
  end;
  if (xmint = 1) then; do;
	  centvars = "(" || mnamemat[1,1] || " + " || mnamemat[1,2] || ")/2";
	  if (mpairs > 1) then; do;
		  do j = 2 to mpairs;
		  	tempnm = "(" || mnamemat[j,1] || " + " || mnamemat[j,2] || ")/2";
		  	centvars = centvars // tempnm;
		  end;
	  end;
	  print centvars [label = "The following variables were mean centered prior to analysis:"];
  end; *if (xmint = 1);

end; *if ((model = 1)|(model > 3));


if ((model ^= 1)&(center>0)) then; do;
	%dichot(modcount = Wcount, dat = moddat);
	if ((wcount-(center=2)*dich[+,1])>0) then; do;
		centvars = j(1, wcount-(center=2)*dich[+,1], -999);
		indx = 1;
		do i = 1 to wcount;
			if((center=1)|(dich[i,1] = 0)) then; do;
				centvars[1,indx] = wnames[1,i];
				indx = indx+1;
			end; *if((center=1)|(dich[i,1] = 0));
		end; *do i = 1 to wcount;
		print centvars [label = "The following moderators were mean centered prior to analysis:"];
	end; *if (wcount-(center=2)*dich[+,1]>0);
	if ((wcount-(center=2)*dich[+,1])<=0) then; do;
		print "No moderators were mean centered prior to analysis";
	end; *if ((wcount-(center=2)*dich[+,1])<=0);
end; *if ((model ^= 1)&(center>0)) ;
print conf [label = "Level of confidence for all confidence intervals in output:"];	

end; *if (criterr=0);


if (criterr = 0) then;do; *5;
  print "****************************************************************************************";
  print model [label = "Model:"];
  varrlabs = {"Y="};
  if ((model ^= 1)&(Wcount = 1)) then; do;
  	varrlabs = varrlabs||"W = ";
  end; *if ((model ^= 1)&(Wcount = 1));
  if ((model ^=1)&(Wcount >1)) then; do;
  	varrlabs = varrlabs||"W1 = "||"W2 = "||"W3 = "||"W4 = "||"W5 = ";
  end;
  if (((model = 1)|(model >= 4))&(mpairs = 1)) then; do;
  	varrlabs = varrlabs||"M = ";
  end; *if (((model = 1)|(model >= 4))&(mpairs = 1));
  if (((model = 1)|(model >= 4))&(mpairs > 1)) then; do;
  	varrlabs=varrlabs||"M1 = "||"M2 = "||"M3 = "||"M4 = "||"M5 = "||"M6 = "||"M7 = "||"M8 = "||"M9 = "||"M10 = ";
	temp9 = {"(M1)" "(M2)" "(M3)" "(M4)" "(M5)" "(M6)" "(M7)" "(M8)" "(M9)" "(M10)"};
  end; *if (((model = 1)|(model >= 4))&(mpairs > 1));

  if (model = 1) then; do;
  	tttt=ynames//mnamemat;
  	print tttt [label = "Variables:" rowname=varrlabs];
  end; *if (model = 1);
  if ((model =2)|(model=3)) then; do;
    tttt = ynames//wnamemat;
  	print tttt [label = "Variables:" rowname = varrlabs];
  end; *if ((model =2)|(model=3));
  if (model >=4) then; do;
	wnamemat = t(wnames)||j(Wcount,1," ");
	tttt = ynames//wnamemat//mnamemat;
  	print tttt [label = "Variables:" rowname = varrlabs];
  end;

if ((model = 1)|(model >= 4))then; do;
  *print ((1+xmint+dpathmod+bpathmod)*mpairs+1);
  *compname = j(((1+xmint+dpathmod+bpathmod)*mpairs+1),9," "); 
  compname=" "||ynames[1,1]||" - "||ynames[1,2]||" "||" "||" "||" "||" ";
  do j = 1 to mpairs;
    tttt=" "||mnamemat[j,1]||" - "||mnamemat[j,2]||" "||" "||" "||" "||" ";
    compname=compname//tttt;
  end; *do j = 1 to mpairs;
  if (xmint = 1) then; do;
	  do j = 1 to mpairs;
		tttt="("||mnamemat[j,1]||" + "||mnamemat[j,2]||")"||"/2"||" "||" "||"Centered";
		compname=compname//tttt;
	  end; *do j = 1 to mpairs;
  end; *if (xmint = 1);
  temp1={"M1diff = " "M2diff = " "M3diff = " "M4diff = " "M5diff = " "M6diff = " "M7diff = " "M8diff = " "M9diff = " "M10diff = "};
  temp2={"M1avg = " "M2avg = " "M3avg = " "M4avg = " "M5avg = " "M6avg = " "M7avg = " "M8avg = " "M9avg = " "M10avg = "};
  temp6={"M1diff" "M2diff" "M3diff" "M4diff" "M5diff" "M6diff" "M7diff" "M8diff" "M9diff" "M10diff"};
  temp7={"M1avg" "M2avg" "M3avg" "M4avg" "M5avg" "M6avg" "M7avg" "M8avg" "M9avg" "M10avg"};
  if(xmint = 1) then; do;
  	if (mpairs = 1) then; do;
		temprnam = {"Ydiff = " "Mdiff = " "Mavg = "};
	end; *if (mpairs = 1);
	if (mpairs ^= 1) then;do;
    	temprnam = {"Ydiff = "}||temp1[1,1:mpairs]||temp2[1,1:mpairs];
  	end;
  end; *if(xmint = 1);
  if(xmint = 0) then; do;
  	if (mpairs = 1) then; do;
		temprnam = {"Ydiff = " "Mdiff = "};
	end; *if (mpairs = 1);
	if (mpairs ^= 1) then;do;
    	temprnam= {"Ydiff = "}||temp1[1,1:mpairs];
  	end;
  end; *if(xmint = 0);
  temp3 = {"Int1 = " "Int2 = " "Int3 = " "Int4 = " "Int5 = " "Int6 = " "Int7 = " "Int8 = " "Int9 = " "Int10 = "};
  temp4 = {"Int11 = " "Int12 = " "Int13 = " "Int14 = " "Int15 = " "Int16 = " "Int17 = " "Int18 = " "Int19 = " "Int20 = "};
  temp5 = {"Int21 = " "Int22 = " "Int23 = " "Int24 = " "Int25 = " "Int26 = " "Int27 = " "Int28 = " "Int29 = " "Int30 = "};
  temprnam = temprnam||temp3||temp4||temp5;
  counter = (1+xmint)*Mpairs+2;
  if(bpathmod = 1) then; do;
  	do j = 1 to mpairs;
	  	compname = compname//(wnamemat[1,1]||"*"||"("||mnamemat[j,1]||"-"||mnamemat[j,2]||")"||" "||" ");
		counter = counter+1;
	end; *do j = 1 to mpairs;
  end; *if(bpathmod = 1);
  if(dpathmod = 1) then; do;
  	do j = 1 to mpairs;
	  	compname = compname//(wnamemat[1,1]||"*"||"("||mnamemat[j,1]||"+"||mnamemat[j,2]||")"||"/2"||"Centered");
		counter = counter+1;
	end; *do j = 1 to mpairs;
  end; *if(bpathmod = 1);
end; *if ((model = 1)|(model >= 4));

if ((model = 2) | ((model = 3)&(wcount = 1))) then; do;
	compname=j(1,7, "        ");
	compname[1,1:4] = {" "}||ynames[1,1]||"-"||ynames[1,2];
	temprnam = {"Ydiff = "};
end;
if ((model = 3) & (wcount > 1)) then; do;
	nint = ncol(moddat) - wcount;
	compcol = 2*wcount-1;
	compname = ynames[1,1] || "-" || ynames[1,2];
	if(wcount>2) then; do;
		compname = compname || J(1,(compcol-3), "         ");
	end; *if(wcount>2);
	temprnam = "Ydiff = ";
	temp1 = {"Int1 = " "Int2 = " "Int3 = " "Int4 = " "Int5 = " "Int6 = " "Int7 = " "Int8 = " "Int9 = " "Int10 = "};
    temp2 = {"Int11 = " "Int12 = " "Int13 = " "Int14 = " "Int15 = " "Int16 = " "Int17 = " "Int18 = " "Int19 = " "Int20 = "};
    temp3 = {"Int21 = " "Int22 = " "Int23 = " "Int24 = " "Int25 = " "Int26 = " "Int27 = " "Int28 = " "Int29 = " "Int30 = "};
	temprnam = {"Ydiff = "}||temp1||temp2||temp3;
	intnames = j(intcount[+,],compcol, "        ");
	intnames[1:wcount, 1] = t(wnames);
	counter = 1;
	do h = 1 to (wcount - 1);
		do i = 1 to (wcount - h);
			rchoosek = comb(wcount-i, h);
			tempcnt = intcount[1:h, 1];
			do j = (tempcnt[+,] - rchoosek + 1) to (tempcnt[+,]);
				intnames[wcount+counter,1:((2*h)+1)] = intnames[i,1] || "x" || intnames[j, 1:(2*h-1)];
				counter = counter + 1;
			end; *do j = (tempcnt[+,] - rchoosek + 1) to (tempcnt[+,]);
		end; *do i = 1 to (wcount - h);
	end; *do h = 1 to (wcount - 1);
	compname = compname//intnames[(wcount +1):(wcount + nint),];
end; *if ((model = 3) & (wcount > 1));

print compname [label="Computed Variables:" rowname=temprnam colname = ""];
print n [label="Sample Size:"];
if (&seed ^= 0) then;do;
  seedt=&seed;
  print seedt [label = "Custom seed:"];
end;
if ((model = 1)|(model >=4)) then; do;
	print "****************************************************************************************";
  	ylab="Ydiff = "||ynames[1,1]||" - "||ynames[1,2];
  	print ylab [label="Outcome:"];
	collab="Coef"||"SE"||"t"||"p"||"LLCI"||"ULCI";
	if(anymod = 1) then; do;
		clab="R"||"R-sq"||"MSE"||"F"||"df1"||"df2"||"p";
		print cmodsum [label = "Model Summary" colname = clab format = &decimals];
	end; *if(anymod = 1);
  	rowlab="Constant" || "W";
  print cresmat [label = "Model" rowname=rowlab colname = collab format=&decimals];
  print M4df2 [label = "Degrees of freedom for all regression coefficient estimates:"];
  if(anymod >0) then; do;
  	coeflabs = "Effect"||"SE"||"t"||"p"||"LLCI"||"ULCI";
	XYgWlabs = wnames||coeflabs;
	condnam = j(3,3,"         ");
	condnam[,1] = "Focal:"//"Outcome:"//"Mod:";
	condnam[,2] = "'X'"//"Ydiff"//wnamemat[1,1];
	condnam[,3] = "(X)"//"(Y)"//"(W)";
	print condnam [label = "Conditional Effect of Focal Predictor on Outcome at values of of Moderator(s)"];
	print XYgWres [colname = XYgWlabs format = &decimals label = " "];
	if (quantile = 1) then print "Values for quantitative moderators are 10th, 25th, 50th, 75th, and 90th percentile.";
	if (quantile = 0) then print "Values for quantitative moderators are the mean and plus/minus one SD from the mean.";
	if (dich[+,1] > 0) then print  "Values for dichotomous moderators are the two values of the moderator.";
	if (setswv > 0) then; do;
		print XYgWvres [label = "Conditional effect of Focal Predictor on Outcome at requested values of moderator(s)" colname = XYgWlabs rowname = " " format = &decimals];
		print M4df2 [label = "Degrees of freedom for all conditional effects:"];
	end; *if (setswv > 0);
	if (jn = 1) then; do;
		print "-------------------------------------------------------------------------------------------------";
		print "                                JOHNSON-NEYMAN PROCEDURE: Total Effect Model                                ";
		if (cnumJN ^= 0) then; do;
			print (cJNsoln || t(pcntabv)) [label = "Moderator value(s) defining Johnson-Neyman significance region(s) and percent of observed data above value:" colname = {"Value" "% Abv"} format = &decimals];
		end; *if (cnumJN ^= 0);
		if (cnumJN = 0) then print "There are no statistically significant transition points within the observed range of data.";
		print cJNRes [label = "Conditional Effect of 'X' on Y at values of moderator" colname = XYgWlabs rowname = " " format = &decimals];
		print M4df2 [label = "Degrees of freedom for all conditional effects:"];
	end; *if (jn = 1);
  end; *if(anymod>0);
  print "****************************************************************************************";
  alabs = {"a1" "a2" "a3" "a4" "a5" "a6" "a7" "a8" "a9" "a10"};
  start = 1;
  do j = 1 to Mpairs;
    if (mpairs=1) then;do;
       mlab="Mdiff = "||mnamemat[j,1]||" - "||mnamemat[j,2];
       print mlab [label="Outcome:"];
    end;
	if (mpairs > 1) then;do;
       mlab=temp1[1,j]||mnamemat[j,1]||" - "||mnamemat[j,2];
       print mlab [label="Outcome:"];
    end;
	if ((serial = 1) & ( j > 1)) then; do;
		clab="R"||"R-sq"||"MSE"||"F"||"df1"||"df2"||"p";
		smodtemp = smodsum[j-1,];
		print smodtemp [label = "Model Summary" colname = clab format = &decimals];
		if (xmint = 1) then; do;
			m2labs = "constant"||"M1diff" || "M1avg" || "M2diff" || "M2avg" || "M3diff" || "M3avg" || "M4diff" || "M4avg";
			end = j##2 - 1;
		end;
		if (xmint = 0) then; do;
			m2labs = "constant"||"M1diff" || "M2diff" || "M3diff" || "M4diff";
			end = ((j-1)##2 + 3*(j-1))/2;
		end;

		sertemp = serres[start:end,];
		print sertemp [label = "Model" rowname = m2labs colname = collab format = &decimals];
		start = end + 1;
		smodtemp = smodtemp[1,6];
		print smodtemp [label = "Degrees of freedom for all regression coefficient estimates:"];
	end; *if ((serial = 1) & ( j > 1));
	else do; *if ((serial = 1) & ( j > 1));
		if(apathmod=1) then; do;
			print (amodsum[j,]) [label = "Model Summary" colname = clab format = &decimals];
			rowj = j*(1+Wcount)-Wcount;
			print (aresmat[rowj:(rowj+Wcount),]) [label = "Model" rowname = rowlab colname = collab format = &decimals];
		end; *if(apathmod=1);
		if(apathmod=0) then; do;
			print(aresmat[j,]) [label = "Model" rowname = "constant" colname = collab format = &decimals];
		end; *if(apathmod=0);
		print M3df2 [label = "Degrees of freedom for all regression coefficient estimates:"];
		if(apathmod=1) then; do;
		  	coeflabs = "Effect"||"SE"||"t"||"p"||"LLCI"||"ULCI";
			XMgWlabs = wnames||coeflabs;
			if(mpairs = 1) then condnam[,2] = "'X'"//"Mdiff"//wnamemat[1,1];
			if(mpairs > 1) then condnam[,2] = "'X'"//temp6[1,j]//wnamemat[1,1];
			condnam[,3] = "(X)"//"(M)"//"(W)";
			print condnam [label = "Conditional Effect of Focal Predictor on Outcome at values of of Moderator(s)"];
			print (XMgWres[(j*dimmc-(dimmc-1)):(j*dimmc),]) [colname = XYgWlabs format = &decimals label = " "];
			if (quantile = 1) then print "Values for quantitative moderators are 10th, 25th, 50th, 75th, and 90th percentile.";
			if (quantile = 0) then print "Values for quantitative moderators are the mean and plus/minus one SD from the mean.";
			if (dich[+,1] > 0) then print  "Values for dichotomous moderators are the two values of the moderator.";
			if (setswv > 0) then; do;
				print condnam [Label = "Conditional Effect of Focal Predictor on Outcome at requested values of moderator(s)"];
				print (XMgWvres[(j*setswv-(setswv-1)):(j*setswv),]) [colname = XYgWlabs rowname = " " format = &decimals];
			end; *if (setswv > 0);
			print M3df2 [label = "Degrees of freedom for all conditional effects:"];
			if (jn = 1) then; do;
				print "-------------------------------------------------------------------------------------------------";
				print "                                JOHNSON-NEYMAN PROCEDURE: Mediator Model                                ";
				if (mpairs = 1) then; do;
					mlab="Mdiff = "||mnamemat[j,1]||" - "||mnamemat[j,2];
       				print mlab [label="Outcome:"];
				end; *if (mpairs = 1);
				if(mpairs >1) then; do;
					mlab = temp1[1,j]||mnamemat[j,1]||" - "||mnamemat[j,2];
					print mlab [label = "Outcome:"];
				end; *if(mpairs >1);
				if (anumJN ^= 0) then; do;
					print (t(aJNsoln[j,1:aNumJN[j,1]]) || t(apcntabv[j,1:aNumJN[j,]])) [label = "Moderator value(s) defining Johnson-Neyman significance region(s) and percent of observed data above value:" colname = {"Value" "% Abv"} format = &decimals];
				end; *if (cnumJN ^= 0);
				if (anumJN[j,1] = 0) then print "There are no statistically significant transition points within the observed range of data.";
				print (aJNRes[(1+22*(j-1)):(20+aNumJN[j,1]+22*(j-1)),]) [label = "Conditional Effect of 'X' on M at values of moderator" colname = XYgWlabs rowname = " " format = &decimals];
				print M3df2 [label = "Degrees of freedom for all conditional effects:"];
			end; *if (jn = 1);
		end; *if(anymod >0);
	end; *else if ((serial = 1) & ( j > 1));
  end; *do j = 1 to Mpairs;
end; *if ((model = 1)|(model >=4));

print "****************************************************************************************";
  ylab="Ydiff = "||ynames[1,1]||" - "||ynames[1,2];
  print ylab [label="Outcome:"];
  modsumr=Rfull||Rsqfull||MSR||Ffull||df1||df2||pfull;
  clab="R"||"R-sq"||"MSE"||"F"||"df1"||"df2"||"p";
  collab="coef"||"SE"||"t"||"p"||"LLCI"||"ULCI";
  print modsumr [label="Model Summary" colname=clab format = &decimals];
  if ((model = 1)|(model >=4)) then; do;
  	if(xmint = 1) then modres = cpresmat//bresmat//dresmat;
	if(xmint = 0) then modres = cpresmat//bresmat;
	bdlabs = {"M1diff" "M2diff" "M3diff" "M4diff" "M5diff" "M6diff" "M7diff" "M8diff" "M9diff" "M10diff"};
	bslabs = {"M1avg" "M2avg" "M3avg" "M4avg" "M5avg" "M6avg" "M7avg" "M8avg" "M9avg" "M10avg"};
	intlabs1 = {"Int1" "Int2" "Int3" "Int4" "Int5" "Int6" "Int7" "Int8" "Int9" "Int10"};
	intlabs2 = {"Int11" "Int12" "Int13" "Int14" "Int15" "Int16" "Int17" "Int18" "Int19" "Int20"};
	intlabs3= {"Int21" "Int22" "Int23" "Int24" "Int25" "Int26" "Int27" "Int28" "Int29" "Int30"};
	intlabs = intlabs1 || intlabs2 || intlabs3;
	if(mpairs = 1) then; do;
		modlabs = "constant";
		if(cppthmd=1) then modlabs = modlabs||"W";
		modlabs = modlabs||"Mdiff";
		intcount = 1;
		if(bpathmod = 1) then; do;
			modlabs = modlabs||intlabs[1,intcount];
			intcount = intcount + 1;
		end; *if(bpathmod = 1);
		modlabs = modlabs||"Mavg"||intlabs[1,intcount];
		bdlabs = "Mdiff";
	end; *if(mpairs = 1);
	if(mpairs ^=1) then; do;
		modlabs = "constant";
		if(cppthmd = 1) then modlabs = modlabs||"W";
		modlabs = modlabs||bdlabs[1,1:Mpairs];
		intcount = 1;
		if(bpathmod = 1) then; do;
			modlabs = modlabs||intlabs[1,intcount:(intcount+Mpairs-1)];
			intcount = intcount+mpairs;
		end; *if(bpathmod = 1);
		modlabs = modlabs||bslabs[1,1:Mpairs]||intlabs[1,intcount:(intcount+mpairs-1)];
	end; *if(mpairs ^=1);
  end; *if ((model = 1)|(model >=4));
  if ((model = 2) | (model = 3)) then; do;
  	wlabs = wnames;
	intlabs1 = {"Int1" "Int2" "Int3" "Int4" "Int5" "Int6" "Int7" "Int8" "Int9" "Int10"};
	intlabs2 = {"Int11" "Int12" "Int13" "Int14" "Int15" "Int16" "Int17" "Int18" "Int19" "Int20"};
	intlabs3= {"Int21" "Int22" "Int23" "Int24" "Int25" "Int26" "Int27" "Int28" "Int29" "Int30"};
	intlabs = intlabs1 || intlabs2 || intlabs3;
	modlabs = "constant" || wlabs;
	if ((model = 3)& (wcount > 1)) then; do;
		modlabs = modlabs || intlabs[1, 1:nint];
	end; *if ((model = 3)& (wcount > 1));
  end; *if ((model = 2) | (model = 3));		
  print modres [label = "Model" rowname = modlabs colname=collab format = &decimals];
  print df2 [label = "Degrees of freedom for all regression coefficient estimates:"];
if(cppthmd = 1) then; do;
	print "---------------------------------------------------------------------------------------";
	XYgWcMlb = wnames;
	if(xmint = 1) then; do;
		if(mpairs = 1) then bsmpairs = "Mavg";
		if(mpairs > 0) then bsmpairs = bslabs[1:mpairs];
		XYgWcMlb = XYgWcMlb||t(bsmpairs);
	end;*if(xmint = 1);
	XYgWcMlb = XYgWcMlb||coeflabs;
	condnam[,2] = "'X'"//"Ydiff"//wnamemat[1,1];
	print condnam [label = "Conditional Effect of Focal Predictor on Outcome at values of Moderator(s)"];
	print XYgWcMrs [colname = XYgWcMlb rowname = " " format = &decimals];
	if (quantile = 1) then print "Values for quantitative moderators are 10th, 25th, 50th, 75th, and 90th percentile.";
	if (quantile = 0) then print "Values for quantitative moderators are the mean and plus/minus one SD from the mean.";
	if (dich[+,1] > 0) then print  "Values for dichotomous moderators are the two values of the moderator.";
	if(xmint=1) then print "Values for mediator averages (Mavg) are the conditional values based on the values of the moderator.";
	if(setswv>0) then; do;
		print condnam [label = "Conditional effect of Focal Predictor on Outcome at requested values of moderator(s)"];
		print XYgWcMv [label = " " colname = XYgWcMlb format = &decimals];
		if(xmint=1) then print "Values for mediator averages (Mavg) are the conditional values based on the values of the moderator.";
	end; *if(setswv>0);
	if(jn=1) then; do;
		print "-------------------------------------------------------------------------------------------------";
		print "                                JOHNSON-NEYMAN PROCEDURE: Direct Effect                                ";
		if(cpNumJN ^= 0) then; do;
			print (cpJNsoln|| cppcntabv) [label = "Moderator value(s) defining Johnson-Neyman significance region(s) and percent of observed data above value:" colname = {"Value" "% Abv"} format = &decimals];
		end;
		if (cpNumJN = 0) then print "There are no statistically significant transition points within the observed range of data.";
		print (cpJNRes) [label = "Conditional Effect of 'X' on Y at values of moderator, controlling for M" colname = XYgWlabs rowname = " " format = &decimals];
		print M3df2 [label = "Degrees of freedom for all conditional effects:"];
	end; *if(jn=1);
end; *if(cppthmd = 1);

if(bpathmod=1)then; do;
	do j = 1 to mpairs;
		if(mpairs = 1) then condnam[,2] = "Mdiff"//"Ydiff"//wnamemat[1,1];
		if(mpairs >1) then condnam[,2] = temp6[1,j]//"Ydiff"//wnamemat[1,1];
		condnam[,3] = "(M)"//"(Y)"//"(W)";
		print condnam [label = "Conditional Effect of Focal Predictor on Outcome at values of Moderator(s)"];
		print (MYgWres[(j*dimmc-(dimmc-1)):(j*dimmc),]) [label = "" colname = XYgWlabs format = &decimals];
		if (quantile = 1) then print "Values for quantitative moderators are 10th, 25th, 50th, 75th, and 90th percentile.";
		if (quantile = 0) then print "Values for quantitative moderators are the mean and plus/minus one SD from the mean.";
		if (dich[+,1] > 0) then print  "Values for dichotomous moderators are the two values of the moderator.";
		if(setswv>0) then; do;
			print condnam [label = "Conditional effect of Focal Predictor on Outcome at requested values of moderator(s)"];
			print (MYgWvres[(j*setswv-(setswv-1)):(j*setswv),]) [label = " " colname = XYgWlabs format = &decimals];
		if(xmint=1) then print "Values for mediator averages (Mavg) are the conditional values based on the values of the moderator.";
	end; *if(setswv>0);
	if(jn=1) then; do;
		print "                                JOHNSON-NEYMAN PROCEDURE: b-paths (Mdiff --> Y)                                ";
		if(bNumJN[j,1] ^= 0) then; do;
			bJNtemp = bJNsoln[j,1:(bNumJN[j,1])]|| bpcntabv[j,1:(bNumJN[j,1])];
			print bJNtemp [label = "Moderator value(s) defining Johnson-Neyman significance region(s) and percent of observed data above value:" colname = {"Value" "% Abv"} format = &decimals];
			end; *if(bNumJN[j,1] ^= 0);
		if (bNumJN[j,1] = 0) then print "There are no statistically significant transition points within the observed range of data.";
		print (bJNRes[(1+22*(j-1)):(20+bNumJN[j,1]+22*(j-1)),]) [label = "Conditional Effect of M on Y at values of moderator, controlling for M" colname = XYgWlabs rowname = " " format = &decimals];
	end; *if(jn=1);
	print "-------------------------------------------------------------------------------------------------";
  end; *do j = 1 to mpairs;
end; *if(bpathmod=1);

if(dpathmod=1)then; do;
	print "-------------------------------------------------------------------------------------------------";
	do j = 1 to mpairs;
		if(mpairs = 1) then condnam[,2] = "Mavg"//"Ydiff"//wnamemat[1,1];
		if(mpairs >1) then condnam[,2] = temp7[1,j]//"Ydiff"//wnamemat[1,1];
		condnam[,3] = "(XM)"//"(Y)"//"(W)";
		print condnam [label = "Conditional Effect of Focal Predictor on Outcome at values of Moderator(s)"];
		print (MAYgWres[(j*dimmc-(dimmc-1)):(j*dimmc),]) [label = "" colname = XYgWlabs format = &decimals];
		if (quantile = 1) then print "Values for quantitative moderators are 10th, 25th, 50th, 75th, and 90th percentile.";
		if (quantile = 0) then print "Values for quantitative moderators are the mean and plus/minus one SD from the mean.";
		if (dich[+,1] > 0) then print  "Values for dichotomous moderators are the two values of the moderator.";
		if(setswv>0) then; do;
			print condnam [label = "Conditional effect of Focal Predictor on Outcome at requested values of moderator(s)"];
			print (MAYgWvres[(j*setswv-(setswv-1)):(j*setswv),]) [label = " " colname = XYgWlabs format = &decimals];
		if(xmint=1) then print "Values for mediator averages (Mavg) are the conditional values based on the values of the moderator.";
	end; *if(setswv>0);
	if(jn=1) then; do;
		print "                                JOHNSON-NEYMAN PROCEDURE: d-paths (Mavg --> Y)                                ";
		if(dNumJN[j,1] ^= 0) then; do;
			dJNtemp = dJNsoln[j,1:(dNumJN[j,1])]|| dpcntabv[j,1:(dNumJN[j,1])];
			print dJNtemp [label = "Moderator value(s) defining Johnson-Neyman significance region(s) and percent of observed data above value:" colname = {"Value" "% Abv"} format = &decimals];
			end; *if(dNumJN[j,1] ^= 0);
		if (dNumJN[j,1] = 0) then print "There are no statistically significant transition points within the observed range of data.";
		print (dJNRes[(1+22*(j-1)):(20+dNumJN[j,1]+22*(j-1)),]) [label = "Conditional Effect of Mavg on Y at values of moderator, controlling for M" colname = XYgWlabs rowname = " " format = &decimals];
	end; *if(jn=1);
	print "-------------------------------------------------------------------------------------------------";
  end; *do j = 1 to mpairs;
end; *if(dpathmod=1);

if((cppthmd = 1)|(bpathmod=1)|(dpathmod=1)) then; do;
	print df2 [label = "Degrees of freedom for all conditional effects:"];
end; *if((cppthmd = 1)|(bpathmod=1)|(dpathmod=1));
*print "-------------------------------------------------------------------------------------------------";
if((model=1)|(model>=4)) then; do;
	collab = "Effect"||"SE"||"t"||"df"||"p"||"LLCI"||"ULCI";
	 rwnme=" ";
	if(anymod = 0) then; do; 
		 print "*********************** TOTAL, DIRECT, AND INDIRECT EFFECTS *****************************";
		 cresmat = t(cresmat[1:3]) || dfcpath || t(cresmat[4:6]);
		 print cresmat [label = "Total effect of X on Y" colname=collab rowname = rwnme format = &decimals];
	end; *if(anymod = 0);
	if(anymod >0) then; do;
		print "***************** CONDITIONAL TOTAL, DIRECT, AND INDIRECT EFFECTS ***********************";
		if(setswv>0) then; do;
			XYgWres = XYgWres//XYgWvres;
		end; *if(setswv>0);
		XYgWlabs = XYgWlabs[1:(ncol(XYgWlabs)-3)]// "df"//XYgWlabs[(ncol(XYgWlabs)-2):ncol(XYgWlabs)];
		XYgWres = XYgWres[,1:(ncol(XYgWres)-3)]|| j(nrow(XYgWres), 1, M4df2)||XYgWres[,(ncol(XYgWres)-2):ncol(XYgWres)];
		print XYgWres [label = "Conditional Total Effect of X on Y at values of the Moderator(s)" colname = XYgWlabs rowname=rwnme format = &decimals];
		if (quantile = 1) then print "Values for quantitative moderators are 10th, 25th, 50th, 75th, and 90th percentile.";
		if (quantile = 0) then print "Values for quantitative moderators are the mean and plus/minus one SD from the mean.";
		if (dich[+,1] > 0) then print  "Values for dichotomous moderators are the two values of the moderator.";
		if(setswv>0) then print "Requested values for moderators included in table above.";
	end; *if(anymod >0);
 if(cppthmd = 0) then; do;
 	 cpresmat = t(cpresmat[1:3]) || df2 || t(cpresmat[4:6]);
 	 print cpresmat [label = "Direct effect of X on Y" colname=collab rowname = rwnme format = &decimals];
 end; * if(cppthmd = 0);
 if(cppthmd = 1) then; do;
 	if(setswv>0) then; do;
		XYgWcMrs = XYgWcMrs//XYgWcMv;
	end; *if(setswv>0);
	XYgWcMlb = XYgWcMlb[1:(ncol(XYgWcMlb)-3)]// "df"//XYgWcMlb[(ncol(XYgWcMlb)-2):ncol(XYgWcMlb)];
	XYgWcMrs = XYgWcMrs[,1:(ncol(XYgWcMrs)-3)]|| j(nrow(XYgWcMrs), 1, df2)||XYgWcMrs[,(ncol(XYgWcMrs)-2):ncol(XYgWcMrs)];
	print XYgWcMrs [label = "Conditional Direct Effect of X on Y at values of the Moderator(s)" colname = XYgWcMlb rowname=rwnme format = &decimals];
	if (quantile = 1) then print "Values for quantitative moderators are 10th, 25th, 50th, 75th, and 90th percentile.";
	if (quantile = 0) then print "Values for quantitative moderators are the mean and plus/minus one SD from the mean.";
	if (dich[+,1] > 0) then print  "Values for dichotomous moderators are the two values of the moderator.";
	if (setswv>0) then print "Requested values for moderators included in table above.";
	if (xmint=1) then print "Values for mediator averages (Mavg) are the conditional values based on the values of the moderator.";
 end; * if(cppthmd = 1);

 if (mc = 1) then;do;
   indlabs = {"Effect" "MCSE" "MC LLCI" "MC ULCI"};
   indres=mcres;
 end;
 if (mc ^= 1) then;do;
   indlabs = {"Effect" "Boot SE" "BootLLCI" "BootULCI"};
   indres=bootres;
 end;
 mlab = {"Ind1" "Ind2" "Ind3" "Ind4" "Ind5" "Ind6" "Ind7" "Ind8" "Ind9" "Ind10"};
 mlab2 = {"Ind11" "Ind12" "Ind13" "Ind14" "Ind15" "Ind16" "Ind17" "Ind18" "Ind19" "Ind20"};
 mlab3 = {"Ind21" "Ind22" "Ind23" "Ind24" "Ind25" "Ind26" "Ind27" "Ind28" "Ind29" "Ind30"};
 mlab4 = {"Ind31" "Ind32" "Ind33" "Ind34" "Ind35" "Ind36" "Ind37" "Ind38" "Ind39" "Ind40"};
 mlab = mlab || mlab2 || mlab3 ||mlab4;

if((apathmod=0)&(bpathmod=0)) then; do;
	 m2lab=mlab[1,1:(nrow(indres)-1)]||"Total";
	 if (mpairs = 1) then; do;
	 	print (indres[1,]) [label="Indirect Effect of X on Y through M" rowname=m2lab colname=indlabs format = &decimals];
	 end; *if (mpairs = 1);
	 if (mpairs ^=1) then; do;
	 	print indres [label="Indirect Effect of X on Y through M" rowname=m2lab colname=indlabs format = &decimals];
	 end; *if (mpairs ^=1);
	 if (normal = 1) then;do;
   	 	clab={"Effect" "SE" "Z" "p"};
   		print normres [label = "Normal Theory Test for Indirect Effect" rowname=mlab colname=clab format=&decimals];
 	 end; *if (normal = 1);
end; *if((apathmod=0)&(bpathmod=0));
if ((apathmod=1)|(bpathmod=1)) then; do;
	m2lab = mlab[1,1:mpairs]||"Total";
	indlabsw = wnamemat[1,1]||indlabs;
	condnam1 = "Ind:"|| " " || " ";
	condnam2 = "Med:"|| " " || " ";
	condnam = condnam1//condnam2;
	do i = 1 to mpairs;
		if(mpairs = 1) then; do;
			condnam[2,2] = "Mdiff";
			condnam[2,2] = "(M)";
			condnam[1,2] = "Ind1";
		end; *if(mpairs = 1) ;
		if (mpairs >1) then; do;
			condnam[2,2] = temp6[1,i];
			condnam[2,2] = temp9[1,i];
			condnam[1,2] = mlab[1,i];
		end; *if(mpairs > 1) ;
		print condnam [label = "Conditional Indirect Effect of X on Y through Mediator at values of the Moderator"];
		print (cindres[(1+(i-1)*(dimmc+setswv)):(i*(dimmc+setswv)),]) [colname = indlabsW format = &decimals label = ""];
		if (quantile = 1) then print "Values for quantitative moderators are 10th, 25th, 50th, 75th, and 90th percentile.";
		if (quantile = 0) then print "Values for quantitative moderators are the mean and plus/minus one SD from the mean.";
		if (dich[+,1] > 0) then print  "Values for dichotomous moderators are the two values of the moderator.";
		if (setswv>0) then print "Requested values for moderators included in table above.";
	end; *do i = 1 to mpairs;
end; *if ((apathmod=1)|(bpathmod=1));

 indkey=j((ncol(m2lab)-1),3+2*Mpairs,"        ");
 do i = 1 to mpairs;
   indkey[i,1:5]="X"||"->"||bdlabs[1,i]||"->"||"Ydiff";
 end;
 if (serial = 1) then;do;
   counter = 1;
   do j = 1 to mpairs - 1;
   	do m = 1 to mpairs - j;
		step1 = " 'X' " || "->"||bdlabs[1,m];
		do l = (m+1) to mpairs;
			step2 = step1 || "->" || bdlabs[1,l];
			if (j > 1) then; do;
				do h = (l+1) to mpairs;
					step3 = step2|| "->" || bdlabs[1,h];
					if (j > 2) then; do;
						do o = (h+1) to mpairs;
							step4 = step3 || "->" || bdlabs[1,o];
							if (j > 3) then; do;
								step5 = step4 || "->" || bdlabs[1,5] || "->" || "YDiff";
								indkey[mpairs+counter,1:13] = step5;
								counter = counter + 1;
								goto stpit;
							end; *if (j > 3);
							else do;
								indkey[mpairs+counter,1:11] = step4|| "->" || "YDiff";
								counter = counter +1;
							end; *else;
						end; *do o = (h+1) to mpairs;
					end; *if (j > 2);
					else do;
						indkey[mpairs+counter, 1:9] = step3 || "->" || "YDiff";
						counter = counter + 1;
					end; *else;
				end; *do h = (l+1) to mpairs;
			end; *if (j > 1);
			else do;
				indkey[mpairs+counter,1:7] = step2|| "->" || "YDiff";
				counter = counter + 1;
			end; *else;
		end; *do l = (m+1) to mpairs;
	end; *do m = 1 to mpairs - j;
   stpit:
   end; *do j = 1 to mpairs - 1;
 end; *if (serial = 1);
 if(serial=0) then indkey = indkey[,1:5];

 empty = j(20, 1, " ");
 print indkey [label = "Indirect effect key" rowname=m2lab colname = empty];

 if ((contrast=1) & (mpairs > 1)) then;do;
  contlab="(C1)"//"(C2)"//"(C3)"//"(C4)"//"(C5)"//"(C6)"//"(C7)"//"(C8)"//"(C9)"//"(C10)";
  contlab=contlab//"(C11)"//"(C12)"//"(C13)"//"(C14)"//"(C15)"//"(C16)"//"(C17)"//"(C18)"//"(C19)"//"(C20)";
  contlab=contlab//"(C21)"//"(C22)"//"(C23)"//"(C24)"//"(C25)"//"(C26)"//"(C27)"//"(C28)"//"(C29)"//"(C30)";
  contlab=contlab//"(C31)"//"(C32)"//"(C33)"//"(C34)"//"(C35)"//"(C36)"//"(C37)"//"(C38)"//"(C39)"//"(C40)";
  contlab=contlab//"(C41)"//"(C42)"//"(C43)"//"(C44)"//"(C45)";
  print contres [label="Pairwise Contrasts Between Specific Indirect Effects" rowname=contlab colname=indlabs format=&decimals];
  contkey = " "||" "||" ";
  do i = 1 to (nrow(indres)-2);
    do j = i+1 to (nrow(indres)-1);
	  tttt=mlab[1,i]||" - "|| mlab[1,j];
	  contkey=contkey//tttt;
	end;
  end;
  contkey=contkey[2:nrow(contkey),];
  print contkey [label = "Contrast definitions:" rowname = contlab];
 end; *if ((contrast=1) & (mpairs > 1));
if(anymod >0) then; do;
	print "************************* INDICES OF MODERATION ************************************";
	cresmat = cresmat[2:(1+Wcount), 1:3]||M4df2||cresmat[2:(1+Wcount),4:6];
	print cresmat [label = "Test of Moderation of the Total Effect" rowname="W" colname =collab format=&decimals];
	if(cppthmd=1) then; do;
		cpresmat = cpresmat[2:(1+Wcount),1:3]||df2||cpresmat[2:(1+Wcount),4:6];
		print cpresmat [label = "Test of Moderation of the Direct Effect" rowname="W" colname=collab format=&decimals];
	end; *if(cppthmd=1);
	if((apathmod=1)|(bpathmod=1)) then; do;
		if(dich[+,1]>0) then; do;
			print immres [rowname = mlab colname = indlabs format = &decimals label = "Index of Moderated Mediation for each Indirect Effect"];
		end; *if(dich[+,1]>0);
		if(dich[+,1]=0) then; do;
			if ((apathmod=1)&(bpathmod=1)) then; do;
				print "The INDEX OF MODERATED MEDIATION is not generated for this model because the indirect effect is a non-linear function of the moderator.";
			end; *if ((apathmod=1)&(bpathmod=1));
			if ((apathmod=0)|(bpathmod=0)) then; do;
				indices = 2//4//6//8//10//12//14//16//18//20;
				if (mc = 0) then immres = bootres[indices[1:Mpairs],];
				if (mc = 1) then immres = MCres[indices[1:Mpairs],];
				print immres [rowname = mlab colname = indlabs format = &decimals label = "Index of Moderated Mediation for each Indirect Effect"];
			end; *if ((apathmod=0)|(bpathmod=0));
		end; *if(dich[+,1]=0);
	end; *if((apathmod=1)|(bpathmod =  1));


	if (plot = 1) then; do;
		print "************************************ PLOTS ******************************************";
		plotcol = wnames;
		if(apathmod = 1) then; do;
			if(mpairs = 1) then plotcol = plotcol||"MdiffHAT";
			if(mpairs >1) then; do;
				pctemp = "M1diffHAT"||"M2diffHAT"||"M3diffHAT"||"M4diffHAT"||"M5diffHAT"||"M6diffHAT"||"M7diffHAT"||"M8diffHAT"||"M9diffHAT"||"M10diffHAT";
				plotcol = plotcoll || t(pctemp[1:Mpairs]);
			end; *if(mpairs >1);
		end; *if(apathmod = 1);
		plotcol = plotcol|| "Ydiff";
		print "Data for visualizing conditional effect of X on Y at values of W";
		if(apathmod = 1) then; do;
			print "Data for visualizing conditional effect of X on M at values of W";
		end;
		print plotdat [label = "" format = &decimals rowname = " " colname = plotcol];
		if (center = 1) then print "Note: All moderator values have been centered.";
		if (center = 2) then print "Note: All continuous moderator values have been centered.";
		if(bpathmod = 1) then; do;
			print "------------------------------------------------------------------------------";
			print "Data for visualizing conditional effect of M (Mdiff) on Y at values of W";
			if (mpairs = 1) then bplotlab = wnames||"Mdiff"||"YdiffHAT";
			if (mpairs >1) then; do;
				bptemp = "M1diff"||"M2diff"||"M3diff"||"M4diff"||"M5diff"||"M6diff"||"M7diff"||"M8diff"||"M9diff"||"M10diff";
				do i = 1 to mpairs;
					print (mnames[1,(2*i-1):(2*i)]) [label = "The following section applies to the mediator defined by"];
					bplotlab = wnames||bptemp[i]||"YdiffHAT";
					print (bplotdat[(1+(i-1)*(3*(3-dich[+,1]))):(i*(3*(3-dich[+,1]))),]) [label = " " format = &decimals colname = bplotlab];
				end; *do i = 1 to mpairs;
			end; *if (mpairs >1);
			if (center = 1) then print "Note: All moderator values have been centered.";
			if (center = 2) then print "Note: All continuous moderator values have been centered.";
		end; *if(bpathmod = 1);
		if(cppthmd =1) then; do;
			print "------------------------------------------------------------------------------";
			cppltlab = wnames || "YdiffHAT";
			print cppltdat [label = "Data for visualizing conditional direct effect of X on Y at values of W" format =  &decimals colname = cppltlab];
			if (center = 1) then print "Note: All moderator values have been centered.";
			if (center = 2) then print "Note: All continuous moderator values have been centered.";
			if (xmint = 1) then print "All mediator averages are conditioned on their predicted values based on W.";
		end; *if(cppthmd =1);
		if(dpathmod = 1) then; do;
			print "------------------------------------------------------------------------------";
			print "Data for visualizing differential conditional effect of M (Mavg) on Y at values of W";
			if (center = 1) then print "Note: All moderator values have been centered.";
			if (center = 2) then print "Note: All continuous moderator values have been centered.";
			if (mpairs = 1) then dplotlab = wnames||"Mavg"||"YdiffHAT";
			if (mpairs >1) then; do;
				dptemp = "M1avg"||"M2avg"||"M3avg"||"M4avg"||"M5avg"||"M6avg"||"M7avg"||"M8avg"||"M9avg"||"M10avg";
				do i = 1 to mpairs;
					print (mnames[1,(2*i-1):(2*i)]) [label = "The following section applies to the mediator defined by"];
					dplotlab = wnames||dptemp[i]||"YdiffHAT";
					print (dplotdat[(1+(i-1)*(3*(3-dich[+,1]))):(i*(3*(3-dich[+,1]))),]) [label = "" format = &decimals colname = dplotlab];
				end; *do i = 1 to mpairs;
			end; *if (mpairs >1);
		end; *if(dpathmod = 1);
	end; *if(plot=1);
end;*if(anymod >0);

end;*if((model=1)|(model>=4));
	
if ((model = 2) | (model = 3)) then; do; *11;
	print "****************************************************************************************";
	coeflabs = {"Effect" "SE" "t" "p" "LLCI" "ULCI"};
	XYgWlabs = wnames || coeflabs;
	print XYgWRes [label = "Conditional Effect of 'X' on Y at values of moderator(s)" colname = XYgWlabs rowname = " " format = &decimals];
	print df2 [label = "Degrees of freedom for all conditional effects:"];
	if (quantile = 1) then print "Values for quantitative moderators are 10th, 25th, 50th, 75th, and 90th percentile.";
	if (quantile = 0) then print "Values for quantitative moderators are the mean and plus/minus one SD from the mean.";
	if (dich[+,1] > 0) then print  "Values for dichotomous moderators are the two values of the moderator.";
	if (setswv > 0) then; do;
		print "---------------------------------------------------------------------------------------------";
		print wvres [label = "Conditional effect of 'X' on Y at requested values of moderator(s)" colname = XYgWlabs rowname = " " format = &decimals];
		print df2 [label = "Degrees of freedom for all conditional effects:"];
	end;
	if (jn = 1) then; do;
		print "*************************** JOHNSON-NEYMAN PROCEDURE ******************************";
		if (numJN ^= 0) then; do;
			print (JNsoln || t(pcntabv)) [label = "Moderator value(s) defining Johnson-Neyman significance region(s) and percent of observed data above value:" colname = {"Value" "% Abv"} format = &decimals];
		end;
		if (numJN = 0) then print "There are no statistically significant transition points within the observed range of data.";
		print JNRes [label = "Conditional Effect of 'X' on Y at values of moderator" colname = XYgWlabs rowname = " " format = &decimals];
		print df2 [label = "Degrees of freedom for all conditional effects:"];
	end;
	print "****************************************************************************************";
	print "Conditional Effect of Moderator(s) on Y in each Condition";
	print (ynames[1,1]) [label = "Condition 1 Outcome:"];
	print (prbmsum[1,]) [label = "Model Summary" colname = clab rowname = " " format = &decimals];
	print (prbmdres[1:(nrow(prbmdres)/2), ]) [label = "Model" rowname = modlabs colname = coeflabs format = &decimals];
	print probedf2 [label = "Degrees of freedom for all conditional effects:"];
	print "----------------------------------------------------------------------------------------";
	print (ynames[1,2]) [label = "Condition 2 Outcome:"];
	print (prbmsum[2,]) [label = "Model Summary" colname = clab rowname = " " format = &decimals];
	print (prbmdres[(nrow(prbmdres)/2 + 1):nrow(prbmdres), ]) [label = "Model" rowname = modlabs colname = coeflabs format = &decimals];
	print probedf2 [label = "Degrees of freedom for all conditional effects:"];

	if (plot = 1) then; do;
		print "****************************************************************************************";
		plotcol = wnames|| "Ydiff" || ynames[1,1] || ynames[1,2];
		print plotdat [label = "Data for visualizing conditional effect of 'X' on Y." format = &decimals rowname = " " colname = plotcol];
		if (center = 1) then print "Note: All moderator values have been centered.";
		if (center = 2) then print "Note: All continuous moderator values have been centered.";
	end;

end;*11;

end; *5;


if (criterr=0) then;do;*9;
if ((model = 1)|(model > 3)) then; do; *10;
  savelab=j(1,totsav,"           ");
  blabs="b1"||"b2"||"b3"||"b4"||"b5"||"b6"||"b7"||"b8"||"b9"||"b10";
  bwlabs="b1.1"||"b2.1"||"b3.1"||"b4.1"||"b5.1"||"b6.1"||"b7.1"||"b8.1"||"b9.1"||"b10.1";
  bwintlabs="b1.2"||"b2.2"||"b3.2"||"b4.2"||"b5.2"||"b6.2"||"b7.2"||"b8.2"||"b9.2"||"b10.2";
  awlabs="a1.0"||"a2.0"||"a3.0"||"a4.0"||"a5.0"||"a6.0"||"a7.0"||"a8.0"||"a9.0"||"a10.0";
  awintlabs="a1.1"||"a2.1"||"a3.1"||"a4.1"||"a5.1"||"a6.1"||"a7.1"||"a8.1"||"a9.1"||"a10.1";
  dlabs="d1"||"d2"||"d3"||"d4"||"d5"||"d6"||"d7"||"d8"||"d9"||"d10";
  dwlabs="d1.1"||"d2.1"||"d3.1"||"d4.1"||"d5.1"||"d6.1"||"d7.1"||"d8.1"||"d9.1"||"d10.1";
  dwintlabs="d1.2"||"d2.2"||"d3.2"||"d4.2"||"d5.2"||"d6.2"||"d7.2"||"d8.2"||"d9.2"||"d10.2";
  if (mc = 0) then; do;
  	savelab[1,1] = "c0";
	counter = 2;
  end; *if (mc = 0);
  if (mc = 1) then counter = 1;
  if ((anymod = 1) & (mc = 0)) then; do;
  	savelab[1,counter] = "c1";
	counter = counter + 1;
  end; *if ((anymod = 1) & (mc = 0));
  if (serial = 0) then; do;
  	if (apathmod = 0) then; do;
		savelab[1,counter:(counter+mpairs-1)] = alabs[1, 1:Mpairs];
		counter = counter+Mpairs;
	end; *if (apathmod = 0);
	if (apathmod = 1) then; do;
		alabtemp = t(awlabs[1,1:Mpairs])||t(awintlabs[1,1:Mpairs]);
		alabtemp = shape(alabtemp, 1, mpairs*2);
		savelab[1,counter:(counter+2*mpairs-1)] = alabtemp;
		counter = counter+2*mpairs;
	end; *if (apathmod = 1);
	if (mc = 0) then; do;
		if(cppthmd = 0) then; do;
			savelab[1,counter] = "cp";
			counter = counter + 1;
		end; *if(cppthmd = 0);
		if (cppthmd = 1) then; do;
			savelab[1,counter:(counter+1)] = "cp0"||"cp1";
			counter = counter + 2;
		end; *if (cppthmd = 1);
	end; *if (mc = 0);
	if (bpathmod = 0) then; do;
		savelab[1,counter:(counter+mpairs-1)] = blabs[1,1:mpairs];
		counter = counter+mpairs;
	end; *if (bpathmod = 0);
	if (bpathmod = 1) then; do;
		savelab[1,counter:(counter+mpairs-1)] = bwlabs[1,1:mpairs];
		counter = counter+mpairs;
		savelab[1,counter:(counter+mpairs-1)] = bwintlabs[1,1:mpairs];
		counter = counter+mpairs;
	end; *if (bpathmod = 1);
	if((xmint=1)&(mc=0)) then; do;
		if (dpathmod = 0) then; do;
			savelab[1,counter:(counter+mpairs-1)] = dlabs[1,1:mpairs];
			counter = counter+mpairs;
		end; *if (dpathmod = 0);
		if (dpathmod = 1) then; do;
			savelab[1,counter:(counter+mpairs-1)] = dwlabs[1,1:mpairs];
			counter = counter + mpairs;
			savelab[1,counter:(counter+mpairs-1)] = dwintlabs[1,1:mpairs];
			counter = counter + mpairs;
		end; *if (dpathmod = 1);
	end; *if((xmint=1)&(mc=0));
end; *if (serial = 0);
if (serial = 1) then; do;
	savelab[1,1:2] = "c"||"a1";
	if (xmint = 1) then; do;
		serlab = 'a2'||'f1'||'g1'||'a3'||'f2'||'g2'||'f3'||'g3'||'a4'||'f4'||'g4'||'f5'||'g5'||'f6'||'g6'||'a5'||'f7'||'g7'||'f8'||'g8'||'f9'||'g9'||'f10'||'g10';
		savelab[1,3:(1+mpairs##2)] = serlab[1,1:(mpairs##2-1)];
		savelab[1, 1+mpairs##2] = "cp";
		savelab[1,(3+mpairs##2):(2+mpairs##2+mpairs)] = blabs[1,1:mpairs];
		savelab[1, (3+mpairs##2+mpairs):(2+mpairs##2+2*mpairs)] = dlabs[1,1:mpairs];
	end; *if (xmint = 1);
	if (xmint = 0) then; do;
		serlab = 'a2'||'f1'||'a3'||'f2'||'f3'||'a4'||'f4'||'f5'||'f6'||'a5'||'f7'||'f8'||'f9'||'f10';
		savelab[1, 3:(2+cols)] = serlabs[1, 1:cols];
		savelab[1, 3+cols] = "cp";
		savelab[1,(4+cols):(3+cols+mpairs)] = blabs[1,1:mpairs];
	end; *if (xmint = 0);
end; *if (serial = 1);

if ((mc = 1)&(savboot=1)) then; do;
	savelab = savelab||"TotalInd";
	create &save from mcsave [colname=savelab];
	append from mcsave;
end; *if ((mc = 1)&(&save = 1));
if ((mc ^= 1)&(savboot=1)) then; do;
	create &save from bootsave [colname=savelab];
    append from bootsave;
end; *if ((mc ^= 1)&(&save = 1));

end; *10;

	
end;*9;

quit;
%mend;
