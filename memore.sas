

* MEMORE for SAS Version 2.1;
* Copyright 2018;
* by Amanda K. Montoya and Andrew F Hayes;
* Documentation available online at www.akmontoya.com;
* or by email to akmontoya@psych.ucla.edu;

* Permission is hereby granted, free of charge, to any person obtaining a copy of this software;
* and associated documentation files (the "Software"), to use the software in this form.  Distribution;
* after modification is prohibited, as is its use for any commercial purpose without authorization;  
* This software should not be posted or stored on any webpage, server, or directory accessible to;
* the public whether free or for a charge unless written permission has been granted by the copyright;
* holder.  The copyright holder requests that this software be distributed by directing users to;
* afhayes.com where the latest release of the software and related documentation is archived and;
* can be downloaded;

* THIS SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, ;
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF ;
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT ;
* IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ;
* DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT ;
* OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE ;
* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE ;

* The above text should be included in any distribution of the software;


%macro cdfinvt (p=,df=);
p0=-.322232431088;p1=-1;p2=-.342242088547;p3=-.0204231210245;p4=-.0000453642210148;
q0=.0993484626060;q1=.588581570495;q2=.531103462366;q3=.103537752850;q4=.0038560700634;
ppv=&p;if (&p > .5) then;do;ppv=1-&p;end;
y5=sqrt(-2*log(ppv));
xp=y5+((((y5*p4+p3)*y5+p2)*y5+p1)*y5+p0)/((((y5*q4+q3)*y5+q2)*y5+q1)*y5+q0);
if (&p <= .5) then;do;xp=-xp;end;
toutput=sqrt(&df*(exp((&df-(5/6))*(xp##2)/(&df-(2/3)+.11/&df)##2)-1));
%mend;

%macro memore (data=,y=xxxxxx,m=xxxxxx,w=xxxxxx,conf=95,mc=0,samples=5000,normal=0,bc=0,decimals=10.4,
  save=xxx,seed=0,contrast=0,xmint=1,serial=0, jn = 0, quantile = 0, plot = 0, center = 0,
  wmodval1 = 999.99, wmodval2 = 999.99, wmodval3 = 999.99, model = 1);
options pagesize=32767;
proc iml;
runnotes=j(24,1,0);
criterr=0;
model = &model; 
modelmat = j(3,1,1)*model; 
modelmt2 = {1,2,3};
validtst = (modelmat = modelmt2);
validmod = any(validtst);

if (validmod ^= 1) then;
do;  
	criterr = 1;
	runnotes[23,1] = 23;
end;

w = "&w";
m = "&m";

if ((w = "xxxxxx")&(model ^= 1)) then; 
do;
	criterr = 1; 
	wnames = "xxxxxx";
	mnames = "xxxxxx";
	runnotes[21,1] = 21;
end;

if((m = "xxxxxx") & (model = 1)) then; 
do;
	criterr = 1;
	mnames = "xxxxxx";
	wnames = "xxxxxx";
	runnotes[22,1] = 22;
end;

if (criterr ^= 1) then; 
do;
	use &data;
	read all var{&y} into ydat;
	ynames = {&y};
	if (model = 1) then;
	do;
		read all var{&m} into mdat;
		mnames = {&m};
		read all var{&m &y} into data;
		names = {&m &y};
		wnames = "xxxxxx";
	end;
	else do;
		read all var{&w} into wdat;
		wnames = {&w};
		read all var{&w &y} into data;
		names = {&w &y};
		mnames = "xxxxxx";
	end;
	ninit=nrow(data);
	xx=(data = .);
	xx=xx[,+];
	j=1;do i=1 to nrow(data);if xx[i,1]=0 then;do;data[j,]=data[i,];j=j+1;end;end;
	data=data[1:j-1,];
	missing=ninit-nrow(data);
end;
mc = (&mc = 1);serial = (&serial = 1);jn = (&jn = 1); plot = (&plot = 1); quantile = (&quantile = 1);
center = (&center = 1); contrast = (&contrast = 1); normal = (&normal = 1); xmint = (&xmint = 1);
if (((model = 2) | (model = 3)) & (ncol(wnames)> 1) & (jn = 1)) then;
	do; runnotes[16,1] = 16; jn = 0; end;

if(criterr ^= 1) then; do;
	if (missing > 0) then;do;runnotes[1,1]=1;end;
	if (ncol(ynames) ^= 2) then;do;runnotes[2,1]=2;criterr=1;end;
end;
mcount=ncol(mnames);
wcount = ncol(wnames);
if ("&save" = "") then saveboot="xxx";else saveboot="&save";

if ((model = 2) | (model = 3)) then; do;
	wmodval1 = {&wmodval1};
	wmodval2 = {&wmodval2};
	wmodval3 = {&wmodval3};
	yesval = J(3,1,-999);
	length = yesval;
	modvmat = J(3, wcount, -999);
	failed = 0;
	do i = 1 to 3 until (failed = 1);
		if (i = 1) then wmodval = wmodval1; 
		if (i = 2) then wmodval = wmodval2; 
		if (i = 3) then wmodval = wmodval3; 
		yesval[i,1] = ANY(wmodval - 999.99);
		length[i,1] = (ncol(wmodval) = wcount);
		if ((yesval[i,1] = 1) & (length[i,1] = 1)) then; do; 
			modvmat[i,] = wmodval; 
			setswv = i;
		end;
		if ((yesval[i,1] = 1) & (length[i,1] = 0)) then; do; runnotes[18,1] = 18; setswv = i-1; failed = 1; end;
		if (yesval[i,1] = 0) then; do; setswv = i-1; failed = 1; end;
	end;
	if (setswv > 0) then modvmat = modvmat[1:setswv,]; 
	if (setswv = 0) then modvmat = J(1,1, -999);
end;

if (((mcount < 2) | ((mcount/2) ^= floor(mcount/2)) | (mcount > 20)) & (criterr ^= 1)& (model = 1)) then; do;
  runnotes[6,1]=6;criterr=1;
end;

if(((model = 2) | (model = 3)) & ((wcount = 0) | (wcount > 5))) then; do;
	runnotes[15,1] = 15;
	criterr = 1;
end;

if (criterr = 0) then; do;
	if (model = 1) then; do;
	  do i = 1 to mcount;
	    if ((mnames[1,i]=ynames[1,1]) | (mnames[1,i]=ynames[1,2]) | (ynames[1,1]=ynames[1,2])) then;do;
	      runnotes[8,1]=8;criterr=1;
	    end;
	  end;
	end;
	if (model ^= 1) then; do;
	  do i = 1 to Wcount;
	    if ((wnames[1,i]=ynames[1,1]) | (wnames[1,i]=ynames[1,2]) | (ynames[1,1]=ynames[1,2])) then;do;
	      runnotes[8,1]=8;criterr=1;
	    end;
	  end;
	end;
end;

if ((serial=1) & (mc=1)) then;do;
  runnotes[12,1]=12;mc=0;
end;

if (criterr <> 1) then; do;
	zero=j(nrow(data),1,0);
	do i = 1 to (ncol(data)-1);
	  	do j = i + 1 TO (ncol(data));
		  	diff=data[,i]-data[,j];
		  	copy=(diff=zero);copy=copy[+];
		  	if (copy=nrow(data)) then;do;
		    	copyname=names[1,i]||names[1,j];
				runnotes[7,1]=7;criterr=1;
		  	end;
	  	end;
	end;
end;

if (&samples = 0) then;do;
  samples=5000;mc=1;
end;
if (&samples ^=0) then;do;
  samples=abs(floor(&samples))*(abs(floor(&samples))>=1000)+5000*(abs(floor(&samples))<1000);
end;
if (samples ^= &samples) then;do;
  runnotes[3,1]=3;
end;

conf=&conf;
if ((&conf < 50) | (&conf > 99.99)) then; do;
	conf=95;
	runnotes[5,1]=5;
end;

bc=floor(&bc);if ((mc=1) & (bc=1)) then;do;runnotes[9,1]=9;bc=0;end;
if ((contrast=1) & ((mcount/2)=1) & (model = 1)) then runnotes[10,1]=10;
if ((contrast = 1) & (serial = 1) & (mcount > 6) & (model = 1)) then; do;
	contrast = 0;
	runnotes[20,1] = 20;
end;

if (((mcount < 4) | (mcount > 10)) & (model = 1) & (serial = 1)) then; do;
	runnotes[13,1] = 13;
	criterr = 1;
end;

if ((model = 1)&(center = 1)) then; do;
	runnotes[24,1] = 24;
end;

savboot=0;
if ((saveboot ^= "xxx") & (samples > 0)) then;do;savboot=1;
end;


if (criterr = 0) then; do;
n=nrow(data);
	if (model = 3) then; do;
		intcount = J(wcount,1,-999);
		do i = 1 to wcount;
			intcount[i,1] = comb(wcount,i);
		end;
		nfail = wcount + intcount[+,1] + 2;
	end;
	if (model = 2) then; do;
		nfail = wcount + 2;
	end;
	if (model = 1) then; do;
		nfail = mcount + 2;
	end;
	if (n < nfail) then; do; 
		runnotes[19,1] = 19;
		criterr = 1;
	end;
end;
if (criterr=0) then;do; *1;

  if (model = 1) then; do;
    mpairs=mcount/2;
  	mnamemat=shape(mnames,mpairs,2);
  	transmat={1 0.5, -1 0.5};
  	tmat=j(ncol(data),ncol(data),0);
  	do i = 1 to (2*mpairs+1) by 2;
   	 tmat[i:(i+1),i:(i+1)]=transmat;
  	end;
  datat=data*tmat;
  select = {1 3 5 7 9 11 13 15 17 19 21};
  if (xmint = 0) then; dataT = dataT[,select[1:(Mpairs+1)]];
  if (xmint = 1) then; dataT = datat[,1:(ncol(datat)-1)];
  end;
  if (model = 2) then; do;
  	mpairs = 0;
	moddat = data[,1:wcount];
  	tempvec = J(wcount,1,0);
	temp2 = {1, -1};
	tempvec = tempvec // temp2;
	transmat = (I(wcount)//J(2, wcount,0)) ||tempvec;
	datat = data*transmat;
	if (center = 1) then; do;
		centmean = diag(moddat[+,]/n);
		datat[,1:wcount] = datat[,1:wcount] - J(n, wcount, 1)*centmean;
		moddat = datat[,1:wcount];
	end;
  end;
  if (model = 3) then;do;
    mpairs = 0;
	moddat = data[,1:wcount];
	tempvec = J(wcount,1,0);
	temp2 = {1, -1};
	tempvec = tempvec // temp2;
	transmat = (I(wcount)//J(2, wcount,0)) ||tempvec;
	datat = data*transmat;
	if (center = 1) then; do;
		centmean = diag(moddat[+,]/n);
		datat[,1:wcount] = datat[,1:wcount] - J(n, wcount, 1)*centmean;
		moddat = datat[,1:wcount];
	end;
	if (wcount > 1) then; do;
		do h = 1 to (wcount - 1);
			do i = 1 to (wcount - h);
				counter1 = comb(wcount - i, h);
				counter2 = intcount[1:h, 1];
				do j = (sum(counter2) - counter1 + 1) to (sum(counter2));
					moddat = moddat || (moddat[,i]#moddat[,j]);
				end;
			end;
		end;
	end;
	tempvec = J(ncol(moddat),1,0);
	tempvec = tempvec // {1, -1};
	transmat = (I(ncol(moddat))//J(2, (ncol(moddat)),0)) ||tempvec;
	data = moddat || data[,(ncol(data)-1):ncol(data)];
	datat = data*transmat;
  end;
  
  alpha=(1-.01*conf);
  temp=alpha/2;

if (model = 1) then; do; *3;
  aresmat=j(mpairs,6,0);
  ghostdes=j(n,1,1);
  %cdfinvt (p=temp,df=(n-1));
  tcrita=toutput;
  tcritc=toutput;
  
  counterj = 1;
  do j=1 to (ncol(dataT)-1) by (1+xmint);
  	if (xmint = 1) then; do;
    	summean=datat[,j+1];summean=summean[+,]/n;
    	datat[,j+1]=(datat[,j+1]-summean);
	end;
	apath=inv(ghostdes`*ghostdes)*ghostdes`*datat[,j];
	tempmn=datat[,j];tempmn=tempmn[+,]/n;
	tempsm=datat[,j]-tempmn;tempsm=tempsm#tempsm;tempsm=tempsm[+,]/(n-1);
	semdiff=sqrt(tempsm/n);
    tapath=apath/semdiff;
	dfapath=n-1;
	papath=2*(1-probt(abs(tapath),dfapath));
	lcia=apath-tcrita*semdiff;
	ucia=apath+tcrita*semdiff;
	aresmat[counterj,]=apath||semdiff||tapath||papath||lcia||ucia;
	counterj = counterj + 1;
  end;

  cols = ncol(dataT);
  cpath=inv(ghostdes`*ghostdes)*ghostdes`*datat[,cols];
  tempmn=datat[,cols];tempmn=tempmn[+,]/n;
  tempsm=datat[,cols]-tempmn;tempsm=tempsm#tempsm;tempsm=tempsm[+,]/(n-1);
  seydiff=sqrt(tempsm/n);
  tcpath=cpath/seydiff;
  dfcpath=n-1;
  pcpath=2*(1-probt(abs(tcpath),dfcpath));
  lcic=cpath-tcritc*seydiff;
  ucic=cpath+tcritc*seydiff;
  cresmat=cpath||seydiff||tcpath||pcpath||lcic||ucic;

  if (serial=1) then;do;
  	if (xmint = 1) then cols = mpairs##2 -1;
	if (xmint = 0) then cols = ((mpairs - 1)##2 + 3*(mpairs - 1))/2;	
	serres=j(cols,6,0);
	smodsum = j(mpairs - 1, 7, -999);
	start = 1;
	counterj = 1;
	do j = (2+xmint) to (ncol(dataT) - 1) by (1+xmint);
		serdes=j(n,1,1);serdes=serdes||dataT[,1:(j-1)];
		M2modbs=inv(serdes`*serdes)*serdes`*dataT[,j];
		M2pred=serdes*M2modbs;
	    M2ssr=(datat[,j]-M2pred)##2;M2ssr=M2ssr[+,];
	    tempmn=datat[,j];tempmn=tempmn[+,]/n;
	    M2sst=(datat[,j]-tempmn)##2;M2sst=M2sst[+,];    
		M2Rsq=1-(M2ssr/m2sst);
		m2r=sqrt(M2Rsq);
	    M2msr=M2ssr/(N-ncol(serdes));
		M2df1=ncol(serdes)-1;
		M2df2=(N-ncol(serdes));
		M2F=(m2df2*m2rsq)/(m2df1*(1-m2rsq));
	    M2p=1-probf(M2F,M2df1,M2df2);
	    sem2bmat=(m2msr*inv(serdes`*serdes));
		sem2b=sqrt(vecdiag(sem2bmat));
	    smodsum[counterj,]=M2r||m2rsq||m2msr||m2F||m2df1||m2df2||m2p;
		if (xmint = 1) then end = (counterj +1)##2 - 1;
		if (xmint = 0) then end = (counterj##2 + 3*counterj)/2;
	    %cdfinvt (p=temp,df=m2df2);
	    sercritt=toutput;
		serres[start:end,1]=m2modbs;
		serres[start:end,2]=sem2b;
		serres[start:end,3]=serres[start:end,1]/serres[start:end,2];
		serres[start:end,4]=2*(1-probt(abs(serres[start:end,3]),m2df2));
		serres[start:end,5]=serres[start:end,1]-sercritt*serres[start:end,2];
		serres[start:end,6]=serres[start:end,1]+sercritt*serres[start:end,2];
		aresmat[counterj+1,]=serres[start,];
		start = end+1;
		counterj = counterj + 1;
	end; *doloop;
  end;*serialif;
end; *3;

  bcpdes=j(n,1,1)||datat[,1:(ncol(datat)-1)];
  bcpvec=inv(bcpdes`*bcpdes)*bcpdes`*datat[,ncol(datat)];
  ypred=bcpdes*bcpvec;
  ssr=(datat[,(ncol(datat))]-ypred)##2;ssr=ssr[+,];
  tempmn=datat[,(ncol(datat))];tempmn=tempmn[+,]/n;
  sst=(datat[,(ncol(datat))]-tempmn)##2;sst=sst[+,];
  msr=ssr/(n-ncol(bcpdes));
  rsqfull=1-ssr/sst;
  rfull=sqrt(rsqfull);
  df1=ncol(bcpdes)-1;df2=n-ncol(bcpdes);
  Ffull=(df2*rsqfull)/(df1*(1-rsqfull));
  pfull=1-probf(Ffull,df1,df2);
  sebcpmat=msr*inv(bcpdes`*bcpdes);
  sebcp=sqrt(vecdiag(sebcpmat));

  modsumr = rfull || rsqfull || msr || ffull || df1 || df2 || pfull;

  %cdfinvt (p=temp,df=df2);
  tcritb=toutput;tcritcp=toutput;tcritd=toutput;

  lcii=floor((1-.01*conf)/2*samples);
  ucii=floor((1-((1-.01*conf)/2))*samples)+1;
  if ((lcii < 1) | (ucii > samples)) then; do;runnotes[4,1]=4;criterr=1;lcii=1;ucii=samples;end;

if (model = 1) then; do; *3;
    bresmat=j(mpairs,6,0);dresmat=j(mpairs,6,-999);
	serind = 0;
	do i = 2 to mpairs;
		rchoosek = comb(mpairs, i);
		serind = serind + rchoosek;
	end;
    indres=j(Mpairs+1+serind*(serial=1),1,0);
   if (normal=1) then;do;
     normres=j(mpairs,4,0);
   end;
  cppath=bcpvec[1,1];
  secppath=sebcp[1,1];
  tcppath=cppath/secppath;
  pcppath=2*(1-probt(abs(tcppath),df2));
  lcicp=cppath-tcritcp*secppath;
  ucicp=cppath+tcritcp*secppath;
  cpresmat=cppath||secppath||tcppath||pcppath||lcicp||ucicp;
if (mc = 1) then;do;
    mcsamps=samples;
    randsamp=sqrt(-2*log(ranuni(j(mcsamps,mpairs,&seed))))#cos((2*3.14159265358979)*(ranuni(j(mcsamps,mpairs))));
	mcres=j(mpairs+1,4,0);
	mccorr=j(mpairs,mpairs,1);
	counteri = 1;
	do i = 2 to (nrow(sebcpmat) - xmint) by (1+xmint);
	  mccorr[counteri,counteri]=sebcpmat[i,i];
	  if ((mpairs > 1) & (counteri ^= mpairs)) then;do;
	  	counterj = counteri + 1;
	    do j=(i+1+xmint) to (nrow(sebcpmat) - xmint) by (1+xmint);
		  mccorr[counteri,counterj]=sebcpmat[i,j];
		  mccorr[counterj,counteri]=sebcpmat[i,j];
		  counterj = counterj + 1;
		end;
	  end;
	  counteri = counteri + 1;
	end;
	rndnb=randsamp*root(mccorr);
    rndna=sqrt(-2*log(ranuni(j(mcsamps,mpairs))))#cos((2*3.14159265358979)*(ranuni(j(mcsamps,mpairs))));
    mcsave=j(samples,(3*mpairs+1),0);
	mcsave2=j(samples,mpairs,0);
end;

counteri = 1;
do i = 2 to (nrow(bcpvec) - xmint) by (1+xmint);
    bpath=bcpvec[i,1];sebpath=sebcp[i,1];
	tbpath=bpath/sebpath;
	pbpath=2*(1-probt(abs(tbpath),df2));
	lcib=bpath-tcritb*sebpath;
	ucib=bpath+tcritb*sebpath;
	bresmat[counteri,]=bpath||sebpath||tbpath||pbpath||lcib||ucib;
	if (xmint = 1) then; do;
		dpath=bcpvec[i+1,1];
		sedpath=sebcp[i+1,1];
		tdpath=dpath/sedpath;
		pdpath=2*(1-probt(abs(tdpath),df2));
		lcid=dpath-tcritd*sedpath;
		ucid=dpath+tcritd*sedpath;
		dresmat[counteri,]=dpath||sedpath||tdpath||pdpath||lcid||ucid;
	end;
	indirect=aresmat[counteri,1]*bresmat[counteri,1];
	indres[counteri,1]=indirect;
	if (normal = 1) then;do;
      sobseab=sqrt(((aresmat[counteri,1]##2)*(bresmat[counteri,2]##2))+((bresmat[counteri,1]##2)*(aresmat[counteri,2]##2)));
	  sobelz=indirect/sobseab;
	  sobelp=2*(probnorm(-abs(sobelz)));
	  normres[counterii,]=indirect||sobseab||sobelz||sobelp;
	end;

	if (mc = 1) then;do;
      asamp=rndna[,counteri]*aresmat[counteri,2]+aresmat[counteri,1];
	  bsamp=rndnb[,counteri]+bresmat[counteri,1];
	  absamp=asamp#bsamp;
      mcgrad=rank(absamp);
	  mcsort=absamp;
	  mcsort[mcgrad]=absamp;
	  mcsave[,(3*counteri-2):(3*counteri)]=asamp||bsamp||absamp;
	  mcsave2[,counteri]=absamp;
	  mcllci=mcsort[lcii,1];
	  mculci=mcsort[ucii,1];
      tempmn=mcsort[+,]/mcsamps;
      tempsm=(mcsort[,1]-tempmn)##2;semc=sqrt(tempsm[+,]/(mcsamps-1));
	  mcres[counteri,]=indirect||semc||mcllci||mculci;
	end;
	counteri = counteri + 1;
  end;

  if (serial = 1) then;do;
  	counter = 1; 
	indse = j(serind, mpairs+1, 1);
	do j = 1 to (mpairs - 1);
		do m = 1 to (mpairs - j);
			step1 = aresmat[m,1];
			rchoosek = comb(mpairs - m, j);
			indse[counter:(counter+rchoosek-1),1] = j(rchoosek,1,aresmat[m,2]##2);
			indse[counter:(counter+rchoosek-1),2:(mpairs+1)] = j(rchoosek, mpairs, aresmat[m,1]##2);
			do l = m to (mpairs - j);
				rchoosek = comb(mpairs-l-1, j-1);
				if (xmint = 1) then srindx2 = (l##2 - 1) + 2*m;
				if (xmint = 0) then srindx2 = l*(l+1)/2 + m;
				step2 = step1*serres[srindx2,1];
				indse[counter:(counter+rchoosek-1),2] = indse[counter:(counter+rchoosek-1),2]*(serres[srindx2,2]##2);
				temp = 1;
				temp = temp || (3:(mpairs+1));
				indse[counter:(counter+rchoosek-1),temp] = indse[counter:(counter+rchoosek-1),temp]*(serres[srindx2,1]##2);
				if (j > 1) then; do;
					do h = (l+1) to (mpairs - j + 1);
						rchoosek = comb(mpairs - h - 1, j - 2);
						if (xmint = 1) then srindx3 = (h##2-1)+2*(l+1);
						if (xmint = 0) then srindx3 = h*(h+1)/2 + l+1;
						step3 = step2*serres[srindx3,1];
	                    indse[counter:(counter+rchoosek-1),3] =   indse[counter:(counter+rchoosek-1),3]*(serres[srindx3,2]##2);
						temp = (1:2) || (4:(mpairs+1));
						indse[counter:(counter+rchoosek-1),temp] = indse[counter:(counter+rchoosek-1),temp]*(serres[srindx3,1]##2);
						if (j > 2) then; do;
							do i = (h+1) to (mpairs - j +2);
								if (xmint = 1) then srindx4 = i##2-1+2*(h-1);
								if (xmint = 0) then srindx4 = i*(i+1)/2 + h+1;
								step4 = step3*serres[srindx4,1]; 
                        		indse[counter,4] = indse[counter,4]*(serres[srindx4,2]##2);
								temp = (1:3)||(5:(mpairs+1));
								indse[counter,temp] = indse[counter,temp]*(serres[srindx4,1]##2);
									if (j > 3) then; do;
										if (xmint = 1) then srindx5 = 23;
										if (xmint = 0) then srindx5 = 14;
									step5 = step4*serres[srindx5,1];
                         			indse[counter,5] =   indse[counter,5]*(serres[srindx5,2]##2);
									temp = (1:4)||(6:(mpairs+1));
                           			indse[counter,temp] = indse[counter,temp]*(serres[srindx5,1]##2);
                        			indres[mpairs+counter,1] = step5*bresmat[5,1];
                        			indse[counter, 6] = indse[counter, 6]*(bresmat[5,2]**2);
	                        		indse[counter,1:5] = indse[counter,1:5]*(bresmat[5,1]**2); 
                        			counter = counter+1;
									end;
									else do;
									bindx = 5;
									if (((srindx4 < 16)&(xmint = 1))|((srindx4 < 10)&(xmint = 1))) then bindx = 4;
									if (((srindx4 < 9)&(xmint = 1))|((srindx4 < 6)&(xmint = 1))) then bindx = 3;
									if (((srindx4 < 4)&(xmint = 1))|((srindx4 < 3)&(xmint = 1))) then bindx = 2;
		                            indres[mpairs+counter,1] = step4*bresmat[bindx,1];
		                            indse[counter, 5] = indse[counter, 5]*(bresmat[bindx,2]**2);
		                            indse[counter,1:4] = indse[counter,1:4]*(bresmat[bindx,1]**2);
									if (mpairs > 4) then indse[counter,6] = 0;
									counter = counter +1;
									end;
							end;
						end;
						else do;
							bindx = 5;
							if (((srindx3 < 16)&(xmint = 1))|((srindx3 < 10)&(xmint = 1))) then bindx = 4;
							if (((srindx3 < 9)&(xmint = 1))|((srindx3 < 6)&(xmint = 1))) then bindx = 3;
							if (((srindx3 < 4)&(xmint = 1))|((srindx3 < 3)&(xmint = 1))) then bindx = 2;
							indres[mpairs+counter,1] = step3*bresmat[bindx,1];
                        	indse[counter, 4] = indse[counter, 4]*(bresmat[bindx,2]**2);
                        	indse[counter,1:3] = indse[counter,1:3]*(bresmat[bindx,1]**2); 
							if (mpairs > 3) then indse[counter, 5:(mpairs+1)] = j(1, ncol(5:(mpairs+1)), 0);
							counter = counter +1;
						end;
					end;
				end;
				else do;
					bindx = 5;
					if (((srindx2 < 16)&(xmint = 1))|((srindx2 < 10)&(xmint = 1))) then bindx = 4;
					if (((srindx2 < 9)&(xmint = 1))|((srindx2 < 6)&(xmint = 1))) then bindx = 3;
					if (((srindx2 < 4)&(xmint = 1))|((srindx2 < 3)&(xmint = 1))) then bindx = 2;
	                indres[mpairs+counter,1] = step2*bresmat[bindx,1];
                  	indse[counter, 3] = indse[counter, 3]*(bresmat[bindx,2]**2); 
                  	indse[counter,1:2] = indse[counter,1:2]*(bresmat[bindx,1]**2);
					if (mpairs > 2) then indse[counter, 4:(mpairs+1)] = j(1, ncol(4:(mpairs+1)), 0);
					counter = counter +1;
				end;
			end; 
			
		end;
	end;
	if (normal = 1) then;do;
      serlind=indres[(mpairs+1):(nrow(indres)-1)];
	  serialse = indse[+,];
      sobelZ=serlind/serialse;
	  sobelp=2*(probnorm(-abs(sobelZ)));
	  serindn=serlind||serialse||sobelZ||sobelp;
	  normres=normres//serindn;
	end;
  end;

  if (mc = 1) then;do;
    mcsave[,3*mpairs+1]=mcsave2[,+];
	mcsort=mcsave[,3*mpairs+1];
    mcgrad=rank(mcsort);
    mcsort2=mcsort;
	mcsort2[mcgrad]=mcsort;
	mcsort=mcsort2;
	mcllci=mcsort[lcii];mculci=mcsort[ucii];
    tempmn=mcsort[+,]/mcsamps;
    tempsm=(mcsort[,1]-tempmn)##2;semc=sqrt(tempsm[+,]/(mcsamps-1));
	mcres[mpairs+1,]=indres[+,]||semc||mcllci||mculci;
	if ((contrast=1) & (mpairs > 1)) then;do;
      npairs = Mpairs*(Mpairs-1)/2; 
	  contres=j(npairs,4,0);
	  contsamp=j(samples,npairs,0);
	  contsort=contsamp;
	  counter=1;
	  do i = 1 to mpairs-1;
	    do j = (i+1) to mpairs;
		  contsamp[,counter]=mcsave2[,i]-mcsave2[,j];
		  contres[counter,1]=indres[i,1]-indres[j,1];
		  tttt=contsamp[,counter];
          tempmn=tttt[+,]/mcsamps;
          tempsm=(tttt[,1]-tempmn)##2;
          contres[counter,2]=sqrt(tempsm[+,]/(mcsamps-1));
          contgrad=rank(tttt);
		  contsort[contgrad,counter]=tttt;
          contres[counter,3]=contsort[lcii,counter];
		  contres[counter,4]=contsort[ucii,counter];
		  counter=counter+1;
		end;
	  end;
	end;
  end;
	badboot = 0;
  if (mc ^= 1) then;do;
  	
	detcheck = j((mpairs-1)*(serial=1)+1,1,-999);
	detsum = detcheck[+,];
    bootsamp=j(samples,mpairs+1+serind*(serial=1),0);
	if(serial = 1) then; do;
		if (xmint = 1) then bootcol = mpairs##2 -1;
		if (xmint = 0) then bootcol = ((mpairs - 1)##2 + 3*(mpairs - 1))/2;
	end;
	if (serial = 0) then bootcol = -999;
	bootsave=j(samples,3*Mpairs+3+(bootcol+serind-mpairs+1)*(serial=1),0);
	indtemp=j(samples,mpairs+serind*(serial=1),0);
	do i = 1 to samples;
		counter1 = 0;
		do until (detsum=0);
			counter1 = counter1+1;
		    sortvar=floor((ranuni(j(n,1,&seed)))*n)+1;
	        bootdat=datat[sortvar,];
			if (xmint = 1) then; do;
			    do j = 1 to mpairs;
		          tempmn=bootdat[,2*j];tempmn=tempmn[+,]/n;
			      bootdat[,2*j]=bootdat[,2*j]-tempmn;
			    end;
			end;
		    bootdes=j(n,1,1)||bootdat[,1:(ncol(bootdat)-1)];
			testi = det(bootdes`*bootdes);
		    detcheck[1,1]=(testi=0);
			if (serial=1) then; do;
				counterj = 2;
				do j = (2+xmint) to (ncol(dataT)-1) by (1+xmint);
					bootadat=bootdes[,1:(j-1)];
					testj = det(bootadat`*bootadat);
					detcheck[counterj,1]=(testj=0);
					counterj = counterj + 1;
				end;
			end;
			detsum=detcheck[+,];
			badboot = badboot+(counter1=2);
		end;
	  bootbeta=inv(bootdes`*bootdes)*bootdes`*bootdat[,ncol(bootdat)];
	  bootavec = j(mpairs, 1, -999);
	  bootbvec = j(mpairs, 1, -999);
	  if (serial = 1) then bootser = j(bootcol,1,-999);
	  start = 1;
	  counterj = 1;
	  do j = 1 to (ncol(dataT) - 1) by (1+xmint);
        bootavec[counterj,1]=inv(ghostdes`*ghostdes)*ghostdes`*bootdat[,j];
	    bootb=bootbeta[j+1,1];
		bootbvec[counterj,1] = bootb;
        if ((serial=1) & (j > 1)) then;do;
		  serdes = j(N,1,1)||bootdat[,1:(j-1)];
		  if (xmint = 1) then end = counterj##2 - 1;
		  if (xmint = 0) then end = ((counterj-1)##2 + 3*(counterj-1))/2;
		  bootser[start:end,1] = inv(serdes`*serdes)*serdes`*bootdat[,j];
		  bootavec[counterj,1] = bootser[start,1];
		  bootsave[i,(2*counterj):(2*counterj+1)] = bootb || bootavec[counterj,1]*bootb;
		  start = end + 1;
	    end;
	    bootsamp[i,counterj]=bootb*bootavec[counterj,1];
        if((serial=0) | (j = 1)) then; do;
			bootsave[i,(3*counterj-2):(3*counterj)] = bootavec[counterj,1] || bootb || bootavec[counterj,1]*bootb;
		end;
		indtemp[i,counterj]=bootavec[counterj,1]*bootb;
		counterj = counterj + 1;
	  end;

	  *serial loop;
	if(serial = 1) then; do;
		bootsave[i, (2+2*mpairs):(1+2*mpairs + bootcol)] = bootser`;
		counter = 1;
		do j = 1 to (mpairs - 1);
			do m = 1 to (mpairs - j);
				step1 = bootavec[m,1];
				do l = m to (mpairs - j);
					if (xmint = 1) then srindx2 = (l##2 -1)+2*m;
					if (xmint = 0) then srindx2 = l*(l+1)/2 + m;
					step2 = step1*bootser[srindx2,1];
					if (j > 1) then; do;
						do h = (l+1) to (mpairs-j+1);
							if (xmint = 1) then srindx3 = h##2 - 1 + 2*(l+1);
							if (xmint = 0) then srindx3 = h*(h+1)/2 + l + 1;
							step3 = step2*bootser[srindx3,1];
							if (j > 2) then; do;
								do o = (h+1) to (mpairs-j+2);
									if (xmint = 1) then srindx4 = o##2 - 1 + 2*(h+1);
									if (xmint = 0) then srindx4 = o*(o+1)/2 + h + 1;
									step4 = step3*bootser[srindx4,1];
									if (j > 3) then; do;
										if (xmint = 1) then srindx5 = 23;
										if (xmint = 0) then srindx5 = 14;
										step5 = step3*bootser[srindx5,1];
										indtemp[i,mpairs+counter] = step5*bootbvec[5,1];
										bootsamp[i,mpairs+counter] = step5*bootbvec[5,1];
										bootsave[i, (1+2*mpairs + bootcol + counter)] = step5*bootbvec[5,1];
										counter = counter +1;
									end;
									else do;
										bindx = 5;
										if (((srindx4 < 16)&(xmint = 1))|((srindx4 < 10)&(xmint = 1))) then bindx = 4;
										if (((srindx4 < 9)&(xmint = 1))|((srindx4 < 6)&(xmint = 1))) then bindx = 3;
										if (((srindx4 < 4)&(xmint = 1))|((srindx4 < 3)&(xmint = 1))) then bindx = 2;
		                            	indtemp[i,mpairs+counter] = step4*bootbvec[bindx,1];
										bootsamp[i, mpairs + counter] = step4*bootbvec[bindx,1];
										bootsave[i,1+2*mpairs + bootcol + counter] = step4*bootbvec[bindx,1];
										counter = counter + 1;
									end; *elseif;
								end; *oloop;
							end;
							else do;
								bindx = 5;
								if (((srindx3 < 16)&(xmint = 1))|((srindx3 < 10)&(xmint = 1))) then bindx = 4;
								if (((srindx3 < 9)&(xmint = 1))|((srindx3 < 6)&(xmint = 1))) then bindx = 3;
								if (((srindx3 < 4)&(xmint = 1))|((srindx3 < 3)&(xmint = 1))) then bindx = 2;
		                        indtemp[i,mpairs+counter] = step3*bootbvec[bindx,1];
								bootsamp[i, mpairs + counter] = step3*bootbvec[bindx,1];
								bootsave[i,1+2*mpairs + bootcol + counter] = step3*bootbvec[bindx,1];
								counter = counter + 1;
							end; *else (j > 2);
						end; *hloop;
					end; *(j > 1);
					else do;
						bindx = 5;
						if (((srindx2 < 16)&(xmint = 1))|((srindx2 < 10)&(xmint = 1))) then bindx = 4;
						if (((srindx2 < 9)&(xmint = 1))|((srindx2 < 6)&(xmint = 1))) then bindx = 3;
						if (((srindx2 < 4)&(xmint = 1))|((srindx2 < 3)&(xmint = 1))) then bindx = 2;
		                indtemp[i,mpairs+counter] = step2*bootbvec[bindx,1];
						bootsamp[i, mpairs + counter] = step2*bootbvec[bindx,1];
						bootsave[i,1+2*mpairs + bootcol + counter] = step2*bootbvec[bindx,1];
						counter = counter + 1;
					end; *elseif ( j > 1);
				end; *lloop;
			end; *mloop;
		end; *jloop;
	end; *serialif;
	
	*direct effect;
	bootsave[i,(ncol(bootsave)-1)]=bootbeta[1,1];
	tempsm=indtemp[i,];
	*total effect;
	bootsave[i,ncol(bootsave)]=tempsm[,+]+bootbeta[1,1];
 end; *iloop;

	if (badboot>0)then; do;
		runnotes[14,1] = 14;
	end;

    if ((contrast = 1) & (mpairs > 1)) then;do;
      npairs = ncol(indtemp)*(ncol(indtemp)-1)/2;
	  contres=j(npairs,4,0);
	  contsamp=j(samples,npairs,0);
	  counter=1;
	  do i = 1 to ncol(indtemp)-1;
	    do j = i+1 to ncol(indtemp);
		contsamp[,counter]=indtemp[,i]-indtemp[,j];
		contres[counter,1]=indres[i,1]-indres[j,1];
		counter=counter+1;
		end;
	  end;
	end;
	tempsm=bootsamp[,1:(ncol(bootsamp)-1)];
    bootsamp[,ncol(bootsamp)]=tempsm[,+];
	bootsave[,(ncol(bootsave)-2)]=tempsm[,+];
	indres[nrow(indres),1]=indres[+,];
	bootsort=bootsamp;
	seboots=j(mpairs+1+serind*(serial=1),1,0);
	bccires=j(4,mpairs+1+serind*(serial=1),0);
	bootllci=j(1,ncol(bootsamp),0);
	bootulci=j(1,ncol(bootsamp),0);
    zalpha2=sqrt(-2*log(alpha/2));
    zalpha2=(zalpha2+((((zalpha2*p4+p3)*zalpha2+p2)*zalpha2+p1)*zalpha2+p0)/((((zalpha2*q4+q3)*zalpha2+q2)*zalpha2+q1)*zalpha2+q0));
    do i = 1 to ncol(bootsamp); 
	  tttt=bootsamp[,i];
      bootgrad=rank(tttt);
      bootsort[bootgrad,i]=tttt;
      tempmn=tttt[+,]/samples;
      tempsm=(tttt[,1]-tempmn)##2;
      seboots[i,1]=sqrt(tempsm[+,]/(samples-1));
	  bootsam2=indres[i,1]//bootsamp[,i];
      bootgra2=rank(bootsam2);
	  if (bc=1) then;do;
	    ttttt=bootsamp[,i];
        tttt=(ttttt < indres[i,1]);bccires[1,i]=tttt[+,]/samples;
        bccires[2,i]=bccires[1,i];
        if (bccires[1,i] > .5) then;do;bccires[2,i]=1-bccires[1,i];end;
		bccires[3,i]=sqrt(-2*log(bccires[2,i]));
		tttt=bccires[3,i];
        bccires[4,i]=tttt+((((tttt*p4+p3)*tttt+p2)*tttt+p1)*tttt+p0)/((((tttt*q4+q3)*tttt+q2)*tttt+q1)*tttt+q0);
        if (bccires[1,i] <= .5) then;do;
		  bccires[4,i]=-bccires[4,i];
		end;
        bcllii=probnorm(2*bccires[4,i]-zalpha2)*samples;
		bcucii=probnorm(2*bccires[4,i]+zalpha2)*samples;
		lcii=round(bcllii);
		ucii=floor(bcucii)+1;
		if ((lcii < 1) | (ucii > samples)) then;do;
		  runnotes[4,1]=4;criterr=1;lcii=1;ucii=samples;
		end;
		bootllci[1,i]=bootsort[lcii,i];
		bootulci[1,i]=bootsort[ucii,i];
	  end;
	end; 
	if (bc ^= 1) then;do;
      bootllci=bootsort[lcii,];
	  bootulci=bootsort[ucii,];
	end;
	bootci=bootllci`||bootulci`;
	bootres=indres||seboots||bootci;
  end; 
  if ((contrast = 1) & (mpairs > 1)) then;do; *2;
    bccicont=j(4,ncol(contsamp),0);
	contsort=contsamp;
	contllci=j(1,ncol(contsamp),0);
	contulci=j(1,ncol(contsamp),0);
    do i = 1 to ncol(contsamp);
      tttt=contsamp[,i];
      contgrad=rank(tttt);
      contsort[contgrad,i]=tttt;
      tempmn=tttt[+,]/samples;
      tempsm=(tttt[,1]-tempmn)##2;contres[i,2]=sqrt(tempsm[+,]/(samples-1));
	  contsam2=contres[i,1]//contsamp[,i];
	  contgra2=rank(contsam2);
	  if (bc=1) then;do;

	    ttttt=contsamp[,i];
        tttt=(ttttt < contres[i,1]);bccicont[1,i]=tttt[+,]/samples;
        bccicont[2,i]=bccicont[1,i];
		if (bccicont[1,i] > .5) then bccicont[2,i]=1-bccicont[1,i];
		bccicont[3,i]=sqrt(-2*log(bccicont[2,i]));
	    tttt=bccicont[3,i];
        bccicont[4,i]=tttt+((((tttt*p4+p3)*tttt+p2)*tttt+p1)*tttt+p0)/((((tttt*q4+q3)*tttt+q2)*tttt+q1)*tttt+q0);
        if (bccicont[1,i] <= 0.5) then bccicont[4,i]=-bccicont[4,i];
        cbcllii=probnorm(2*bccicont[4,i]-zalpha2)*samples;
		cbcucii=probnorm(2*bccicont[4,i]+zalpha2)*samples;
		lcii=round(cbcllii);
		ucii=floor(cbcucii)+1;
		if ((lcii < 1) | (ucii > samples)) then;do;
          runnotes[4,1]=4;lcii=1;ucii=samples;
		end;
		contllci[1,i]=contsort[lcii,i];
		contulci[1,i]=contsort[ucii,i];
	  end;
	end; 
    if (bc ^= 1) then;do;
	  contllci=contsort[lcii,];
	  contulci=contsort[ucii,];
	end;
	contci=contllci`||contulci`;
	contres[,3:4]=contci;
  end; *2;
 end; *3;
if ((model = 2) | (model = 3)) then; do; *4;
	wnamemat = t(wnames) || J(wcount, 1, " ");
	modres = J(ncol(bcpdes), 6, -999);
	modres[,1] = bcpvec;
	modres[,2] = sebcp;
	modres[,3] = modres[,1]/modres[,2];
	modres[,4] = 2*(1-probt(abs(modres[,3]), df2));
	modres[,5:6] = (modres[,1] - tcritb*modres[,2])|| (modres[,1] + tcritb*modres[,2]);

	*Conditional effects of X on Y at values of M;
	dich = J(wcount, 3, -999);
	do i = 1 to wcount;
		dich[i,1] = (ncol(unique(moddat[,i])) = 2);
		if (dich[i,1] = 1) then dich[i, 2:3] = unique(moddat[,i]);
	end;

	if ((quantile = 0) | (plot = 1)) then; do;
		modmeans = moddat[+,1:wcount]/n;
		dmeans = diag(modmeans);
		meansmat = J(n, wcount, 1)*dmeans;
		temp = (moddat[,1:wcount] - meansmat)##2;
		modsds = sqrt(temp[+,]/(n-1));
		dimmc = 3##(wcount - dich[+,1])*2##(dich[+,1]);
		modcomb = J(dimmc, wcount, -999);
		counter = 1;
		last = dimmc;
		do i = 1 to wcount;
			if (dich[i,1] = 0) then; do;
				do j = 1 to counter;
					modcomb[(last*(j-1)+1):(last*j),i] = J(last/3,1, modmeans[1,i] - modsds[1,i])//J(last/3, 1, modmeans[1,i]) // J(last/3, 1, modmeans[1,i] + modsds[1,i]);
				end;
				last = last/3;
				counter = counter*3;
			end;
			if (dich[i,1] = 1) then; do;
				do j = 1 to counter;
					modcomb[(last*(j-1)+1):(last*j),i] = J(last/2, 1, dich[i,2]) // J(last/2, 1, dich[i,3]);
				end;
				last = last/2;
				counter = counter *2;
			end;
		end;
		plotdat = modcomb;
	end;
	if (quantile = 1) then; do;
		perctls = {.10 .25 .50 .75 .90};
		pctindx = round(perctls*N);
		if (pctindx[1,1] < 1) then pctindx[1,1] = 1;
		if (pctindx[1,5] > N) then pctindx[1,5] = N; 
		modtemp = data[,1:wcount];
		modsort = J(N, wcount, -999);
		do i = 1 to wcount;
		      modgrad=rank(modtemp[,i]);
		      modsort[modgrad,i]=moddat[,i];
		end;
		pctnum = modsort[pctindx,];
		dimmc = 5##(wcount - dich[+,1])*2##(dich[+,1]);
		modcomb = J(dimmc, wcount, -999);
		counter = 1;
		last = dimmc;
		do i = 1 to wcount;
			if (dich[i,1] = 0) then; do;
				do j = 1 to counter;
					modcomb[(last*(j-1)+1):(last*j),i] = J(last/5, 1, pctnum[1,i]) // J(last/5,1,pctnum[2,i]) // J(last/5, 1, pctnum[3,i]) // J(last/5, 1, pctnum[4,i]) // J(last/5, 1, pctnum[5,i]);
				end;
			last = last/5;
			counter = counter*5;
			end;
			if (dich[i,1] = 1) then; do;
				do j = 1 to counter;
					modcomb[(last*(j-1)+1):(last*j),i] = J(last/2, 1, dich[i,2]) // J(last/2,1,dich[i,3]);
				end;
			last = last/2;
			counter = counter*2;
			end;
		end; 
	end;

	XYgWres = modcomb || J(nrow(modcomb), 6, -999);
	if (model = 3) then; do;
		do h = 1 to (wcount - 1);
			do i = 1 to (wcount - h);
				rchoosek = comb(wcount-i, h);
				temp = intcount[1:h,1];
				do j = (temp[+,1] - rchoosek + 1) to (temp[+,1]);
					modcomb = modcomb || (modcomb[,i]#modcomb[,j]);
					if (setswv > 0) then modvmat = modvmat || modvmat[,i]#modvmat[,j];
				end;
			end;
		end;
	end;
	modcomb = J(nrow(modcomb), 1, 1) || modcomb;
	XYgWres[,wcount+1] = modcomb*bcpvec;
	XYgWres[,wcount+2] = sqrt(vecdiag(modcomb*sebcpmat*t(modcomb)));
	XYgWres[,wcount+3] = XYgWres[,wcount+1]/XYgWres[,wcount+2];
	XYgWres[,wcount+4] = 2*(1-probt(abs(XYgWres[,wcount+3]), df2));
	XYgWres[,(wcount+5):(wcount+6)] = XYgWres[,wcount+1]-tcritb*XYgWres[,wcount+2]|| XYgWres[,wcount+1]+tcritb*XYgWres[,wcount+2];

	if (setswv > 0) then; do;
		wvres = J(setswv, wcount+6, -999);
		wvres[,1:wcount] = modvmat[,1:wcount];
		modvmat = J(setswv, 1, 1) || modvmat;
		wvres[,wcount+1] = modvmat*bcpvec;
		wvres[,wcount+2] = sqrt(vecdiag(modvmat*sebcpmat*t(modvmat)));
		wvres[,wcount+3] = wvres[,wcount+1]/wvres[,wcount+2];
		wvres[,wcount+4] = 2*(1-probt(abs(wvres[,wcount+3]), df2));
		wvres[,(wcount+5):(wcount+6)] = wvres[,wcount+1]-tcritb*wvres[,wcount+2]|| wvres[,wcount+1]+tcritb*wvres[,wcount+2];
	end;

	if ((dich[+,1] > 0) & (jn = 1)) then; do;
		jn = 0;
		runnotes[17,1] = 17;
	end;

	if (jn = 1) then; do;
		cquad = (bcpvec[1,1]##2)-(tcritb##2)*sebcpmat[1,1];
		bquad = 2*bcpvec[1,1]*bcpvec[2,1] - 2*(tcritb##2)*sebcpmat[1,2];
		aquad = (bcpvec[2,1]##2) - (tcritb##2)*sebcpmat[2,2];
		if ((bquad##2 - 4*cquad*aquad) >= 0) then; do;
			JNsoln = ((-1*bquad + sqrt(bquad##2 - 4*cquad*aquad))/(2*aquad))//((-1*bquad - sqrt(bquad##2 - 4*cquad*aquad))/(2*aquad));
			solngrad = rank(JNsoln);
			JNsoln[solngrad,1] = JNsoln[,1];
			pcntabv = ((moddat || moddat) - (J(N,2,1)*diag(JNsoln))>0);
			pcntabv = pcntabv[+,]/N*100;
			toolow = (pcntabv = 100);
			toohigh = (pcntabv = 0);
			numJN = 2-toohigh[,+]-toolow[,+];
			if (toolow[,+] = 1) then; do;
				JNsoln = JNsoln[2,1];
				pcntabv = pcntabv[2];
			end;
			if (toohigh[,+] = 1) then; do;
				JNsoln = JNsoln[1,1];
				pcntabv = pcntabv[1];
			end;
		end;
		if ((bquad##2 - 4*cquad*aquad) < 0) then; do;
			numJN = 0;
		end;
		if (numJN > 0) then; do;
			JNWcomb = J(20+numJN, 2, 1);
			minw = min(moddat);
			maxw = max(moddat);
			range = maxw - minw;
			do i = 1 to 20;
				JNWcomb[i,2] = minw + range/19*(i-1);
			end;
			if (numJN = 1) then JNWcomb[21,2] = JNsoln;
			if (numJN = 2) then JNWcomb[21:22,2] = JNsoln;
			JNgrad = rank(JNWcomb[,2]);
			JNWcomb[JNgrad,2] = JNWcomb[,2];
			JNres = JNWcomb[,2] || J(nrow(JNWcomb), 6, -999);
			JNres[,2] = JNWcomb*bcpvec;
			JNres[,3] = sqrt(vecdiag(JNWcomb*sebcpmat*t(JNWcomb)));
			JNres[,4] = JNres[,2]/JNres[,3];
			JNres[,5] = 2*(1-probt(abs(JNres[,4]), df2));
			JNres[,6:7] = (JNres[,2] - tcritb*JNres[,3]) || (JNres[,2] + tcritb*JNres[,3]);
		end;
	end;

*Probing Effects of Ws on Y;
prbmsum = J(2,7,-999);
prbmdres = J(2*ncol(bcpdes), 6, -999);
do i = 1 to 2;
	probevec = inv(t(bcpdes)*bcpdes)*t(bcpdes)*data[,(ncol(data)-2 + i)];
	prbypred = bcpdes*probevec;
	probessr = sum((data[,(ncol(data)-2 + i)] - prbypred)##2);
	probesst = sum((data[,(ncol(data)-2 + i)] - sum(data[,(ncol(data)-2 + i)])/N)##2);
	probemsr = probessr/(N-ncol(bcpdes));
	prsqfull = 1 - probessr/probesst;
	prbrfull = sqrt(prsqfull);
	probedf1 = (ncol(bcpdes) - 1);
	probedf2 = (N - ncol(bcpdes));
	prbFfull = probedf2*prsqfull/(probedf1*(1-prsqfull));
	prbpfull = 1 - probf(prbffull, probedf1, probedf2);
	seprbmat = probemsr*inv(t(bcpdes)*bcpdes);
	seprb = (vecdiag(seprbmat))##(1/2);
	prbmsum[i,] = prbrfull || prsqfull || probemsr || prbFfull || probedf1 || probedf2 || prbpfull;

	prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),1] = probevec;
	prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),2] = seprb;
	prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),3] = prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),1]/prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),2];
	prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),4] = 2*(1-probt(abs(prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),3]), df2));
	prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),5:6] = (prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),1] - tcritb*prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),2]) || (prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),1] + tcritb*prbmdres[(ncol(bcpdes)*(i-1)+1):(ncol(bcpdes)*i),2]); 
end;

if (plot = 1) then; do;
	if (quantile = 0) then; do;
		plotdat = XYgWres[,1:(wcount+1)] || J(nrow(XYgWres), 2, -999);
		plotdes = modcomb;
	end;
	if (quantile = 1) then; do;
		plotdes = plotdat;
		plotdat = plotdat || J(nrow(plotdat), 3, -999);
		if (model = 3) then; do;
			do h = 1 to (Wcount - 1);
				do i = 1 to (wcount - h);
					rchoosek = comb(wcount-i, h);
					temp = intcount[1:h, 1];
					do j = (temp[+,] - rchoosek + 1) to (temp[+,]);
						plotdes = plotdes || plotdes[,i]#plotdes[,j];
					end;
				end;
			end;
		end;
		plotdes = J(nrow(plotdes), 1, 1) || plotdes;
		plotdat[,(wcount+1)] = plotdes*bcpvec;
	end;

	*plot of Y for each condition by Ms;
	plotdat[,wcount+2] = plotdes*prbmdres[1:ncol(bcpdes),1];
	plotdat[,wcount+3] = plotdes*prbmdres[(ncol(bcpdes)+1):(2*ncol(bcpdes)),1];
end;

end; *4; 
	
end; *1;

print "************************ MEMORE Procedure for SAS Version 2.1 *************************";
print "Written by Amanda K. Montoya and Andrew F. Hayes";
print "Documentation available at akmontoya.com";
print "****************************************************************************************";
if (criterr = 0) then;do; *5;
  print model [label = "Model:"];
  if (model = 1) then; do;
  varrlabs={"Y = " "M1 = " "M2 = " "M3 = " "M4 = " "M5 = " "M6 = " "M7 = " "M8 = " "M9 = " "M10 = "};
    if (mpairs=1)then varrlabs={"Y = " "M = "};
  end;
  if (model ^= 1) then; do;
  	varrlabs={"Y = " "W1 = " "W2 = " "W3 = " "W4 = " "W5 = "};
	  if (wcount = 1) then varrlabs = {"Y = " "W = "};
  end;

  if (model = 1) then; do;
  	tttt=ynames//mnamemat;
  	print tttt [label = "Variables:" rowname=varrlabs];
  end;
  if (model ^= 1) then; do;
    tttt = ynames//wnamemat;
  	print tttt [label = "Variables:" rowname = varrlabs];
  end;
if (model = 1) then; do; 
  compname=" "||ynames[1,1]||" - "||ynames[1,2]||" "||" "||" ";
  do j = 1 to mpairs;
    tttt=" "||mnamemat[j,1]||" - "||mnamemat[j,2]||" "||" "||" ";
    compname=compname//tttt;
  end;
  if (xmint = 1) then; do;
	  do j = 1 to mpairs;
		tttt="("||mnamemat[j,1]||" + "||mnamemat[j,2]||")"||"/2"||"centered";
		compname=compname//tttt;
	  end;
  end;
  temp1={"M1diff = " "M2diff = " "M3diff = " "M4diff = " "M5diff = " "M6diff = " "M7diff = " "M8diff = " "M9diff = " "M10diff = "};
  temp2={"M1avg = " "M2avg = " "M3avg = " "M4avg = " "M5avg = " "M6avg = " "M7avg = " "M8avg = " "M9avg = " "M10avg = "};
  temprnam={"Ydiff = " "Mdiff = " "Mavg = "};
  if (mpairs ^= 1) then;do;
    temprnam="Ydiff = "||temp1[1,1:mpairs]||temp2[1,1:mpairs];
  end;
  if (xmint = 0) then temprnam = temprnam[,1:(ncol(temprnam) - mpairs)];
end;
if ((model = 2) | ((wcount = 1)&(model ^= 1))) then; do;
	compname=ynames[1,1]||" - "||ynames[1,2];
	temprnam = "Ydiff = ";
end;
if ((model = 3) & (wcount > 1)) then; do;
	nint = ncol(moddat) - wcount;
	compcol = 2*wcount-1;
	compname = ynames[1,1] || "-" || ynames[1,2];
	if (wcount > 2) then; do;
		compname = compname || J(1, (compcol - 3), " ");
	end;
	intlabs1 = {"Int1 = " "Int2 = " "Int3 = " "Int4 = " "Int5 = " "Int6 = " "Int7 = " "Int8 = " "Int9 = " "Int10 = "};
	intlabs2 = {"Int11 = " "Int12 = " "Int13 = " "Int14 = " "Int15 = " "Int16 = " "Int17 = " "Int18 = " "Int19 = " "Int20 = "};
	intlabs3= {"Int21 = " "Int22 = " "Int23 = " "Int24 = " "Int25 = " "Int26 = " "Int27 = " "Int28 = " "Int29 = " "Int30 = "};
	temprnam = "Ydiff = " || intlabs1 || intlabs2 || intlabs3;
	intnames = J(intcount[+,1], compcol, "         ");
	intnames[1:wcount, 1] = t(wnames);
	counter = 1;
	do h = 1 to (wcount - 1);
		do i = 1 to (wcount - h);
			rchoosek = comb(wcount-i, h);
			temp = intcount[1:h, 1];
			do j = (temp[+,] - rchoosek + 1) to (temp[+,]);
				intnames[wcount+counter,1:((2*h)+1)] = intnames[i,1] || "x" || intnames[j, 1:(2*h-1)];
				counter = counter + 1;
			end;
		end;
	end;
	compname = compname // intnames[(wcount +1):(wcount + nint),];
end;

print compname [label="Computed Variables:" rowname=temprnam];
print n [label="Sample Size:"];
if (&seed ^= 0) then;do;
  seedt=&seed;
  print seedt [label = "Custom seed:"];
end;
print "****************************************************************************************";
if (model = 1) then; do; *7;
  ylab="Ydiff = "||ynames[1,1]||" - "||ynames[1,2];
  print ylab [label="Outcome:"];
  collab="coef"||"SE"||"t"||"p"||"LLCI"||"ULCI";
  rowlab="'X'";
  print cresmat [label = "Model" rowname=rowlab colname = collab format=&decimals];
  print dfcpath [label = "Degrees of freedom for all regression coefficient estimates:"];
  print "****************************************************************************************";
  alabs = {"a1" "a2" "a3" "a4" "a5" "a6" "a7" "a8" "a9" "a10"};
  start = 1;
  do j = 1 to Mpairs;
    if (mpairs=1) then;do;
       mlab="Mdiff = "||mnamemat[j,1]||" - "||mnamemat[j,2];
       print mlab [label="Outcome:"];
    end;
	if (mpairs > 1) then;do;
       mlab=temp1[1,j]||mnamemat[j,1]||" - "||mnamemat[j,2];
       print mlab [label="Outcome:"];
    end;
	if ((serial = 1) & ( j > 1)) then; do;
		clab="R"||"R-sq"||"MSE"||"F"||"df1"||"df2"||"p";
		smodtemp = smodsum[j-1,];
		print smodtemp [label = "Model Summary" colname = clab format = &decimals];
		if (xmint = 1) then; do;
			m2labs = " 'X' "||"M1diff" || "M1avg" || "M2diff" || "M2avg" || "M3diff" || "M3avg" || "M4diff" || "M4avg";
			end = j##2 - 1;
		end;
		if (xmint = 0) then; do;
			m2labs = " 'X' "||"M1diff" || "M2diff" || "M3diff" || "M4diff";
			end = ((j-1)##2 + 3*(j-1))/2;
		end;

		sertemp = serres[start:end,];
		print sertemp [label = "Model" rowname = m2labs colname = collab format = &decimals];
		start = end + 1;
		smodtemp = smodtemp[1,6];
		print smodtemp [label = "Degrees of freedom for all regression coefficient estimates:"];
	end;
	else do;
	rowlab="'X'";
	   	print (aresmat[j,]) [label = "Model" rowname = rowlab colname=collab format=&decimals];
		print dfapath [label = "Degrees of freedom for all regression coefficient estimates:"];
	end;
	print "****************************************************************************************";
  end;
end;*7;
  ylab="Ydiff = "||ynames[1,1]||" - "||ynames[1,2];
  print ylab [label="Outcome:"];
  modsumr=Rfull||Rsqfull||MSR||Ffull||df1||df2||pfull;
  clab="R"||"R-sq"||"MSE"||"F"||"df1"||"df2"||"p";
  collab="Effect"||"SE"||"t"||"p"||"LLCI"||"ULCI";
  print modsumr [label="Model Summary" colname=clab format = &decimals];
  if (model = 1) then; do;
	  modres=cpresmat//bresmat;
	  if (xmint = 1) then modres = modres //dresmat;
	  bdlabs = {"M1diff" "M2diff" "M3diff" "M4diff" "M5diff" "M6diff" "M7diff" "M8diff" "M9diff" "M10diff"};
	  bslabs = {"M1avg" "M2avg" "M3avg" "M4avg" "M5avg" "M6avg" "M7avg" "M8avg" "M9avg" "M10avg"};
	  modlabs="'X'"||"Mdiff"||"Mavg";
	  if(mpairs = 1) then bdlabs = {"Mdiff"};
	  if (mpairs ^= 1) then;do;
	    modlabs = "'X'"||bdlabs[1,1:mpairs]||bslabs[1,1:mpairs];
	  end;
  end;
  if ((model = 2) | (model = 3)) then; do;
  	wlabs = wnames;
	modlabs = "constant" || wlabs;
	intlabs1 = {"Int1" "Int2" "Int3" "Int4" "Int5" "Int6" "Int7" "Int8" "Int9" "Int10"};
	intlabs2 = {"Int11" "Int12" "Int13" "Int14" "Int15" "Int16" "Int17" "Int18" "Int19" "Int20"};
	intlabs3= {"Int21" "Int22" "Int23" "Int24" "Int25" "Int26" "Int27" "Int28" "Int29" "Int30"};
	if (model = 3) then; do;
		intlabs = intlabs1 || intlabs2 || intlabs3;
		modlabs = modlabs || intlabs[1, 1:nint];
	end;
  end;		
  print modres [label = "Model" rowname = modlabs colname=collab format = &decimals];
  print df2 [label = "Degrees of freedom for all regression coefficient estimates:"];
if (model = 1) then; do; *6;
 print "*********************** TOTAL, DIRECT, AND INDIRECT EFFECTS *****************************";
 collab="Effect"||"SE"||"t"||"df"||"p"||"LLCI"||"ULCI";
 rwnme=" ";
 cresmat = t(cresmat[1:3]) || dfcpath || t(cresmat[4:6]);
 cpresmat = t(cpresmat[1:3]) || df2 || t(cpresmat[4:6]);
 print cresmat [label = "Total effect of X on Y" colname=collab rowname = rwnme format = &decimals];
 print cpresmat [label = "Direct effect of X on Y" colname=collab rowname = rwnme format = &decimals];
 if (mc = 1) then;do;
   indlabs = {"Effect" "MCSE" "MC LLCI" "MC ULCI"};
   indres=mcres;
 end;
 if (mc ^= 1) then;do;
   indlabs = {"Effect" "Boot SE" "BootLLCI" "BootULCI"};
   indres=bootres;
 end;
 mlab = {"Ind1" "Ind2" "Ind3" "Ind4" "Ind5" "Ind6" "Ind7" "Ind8" "Ind9" "Ind10"};
 mlab2 = {"Ind11" "Ind12" "Ind13" "Ind14" "Ind15" "Ind16" "Ind17" "Ind18" "Ind19" "Ind20"};
 mlab3 = {"Ind21" "Ind22" "Ind23" "Ind24" "Ind25" "Ind26" "Ind27" "Ind28" "Ind29" "Ind30"};
 mlab4 = {"Ind31" "Ind32" "Ind33" "Ind34" "Ind35" "Ind36" "Ind37" "Ind38" "Ind39" "Ind40"};
 mlab = mlab || mlab2 || mlab3 ||mlab4;
 m2lab=mlab[1,1:(nrow(indres)-1)]||"Total";
 if (mpairs = 1) then;do;
   indres=indres[1,];
 end;
 print indres [label="Indirect Effect of X on Y through M" rowname=m2lab colname=indlabs format = &decimals];
 if (normal = 1) then;do;
   clab={"Effect" "SE" "Z" "p"};
   print normres [label = "Normal Theory Test for Indirect Effect" rowname=mlab colname=clab format=&decimals];
 end;
 indkey=j((ncol(m2lab)-1),(3+2*Mpairs),"        ");
 do i = 1 to mpairs;
   indkey[i,1:5]="X"||"->"||bdlabs[1,i]||"->"||"Ydiff";
 end;
 if (serial = 1) then;do;
   counter = 1;
   do j = 1 to mpairs - 1;
   	do m = 1 to mpairs - j;
		step1 = " 'X' " || "->"||bdlabs[1,m];
		do l = (m+1) to mpairs;
			step2 = step1 || "->" || bdlabs[1,l];
			if (j > 1) then; do;
				do h = (l+1) to mpairs;
					step3 = step2|| "->" || bdlabs[1,h];
					if (j > 2) then; do;
						do o = (h+1) to mpairs;
							step4 = step3 || "->" || bdlabs[1,o];
							if (j > 3) then; do;
								step5 = step4 || "->" || bdlabs[1,5] || "->" || "YDiff";
								indkey[mpairs+counter,1:13] = step5;
								counter = counter + 1;
								goto stpit;
							end;
							else do;
								indkey[mpairs+counter,1:11] = step4|| "->" || "YDiff";
								counter = counter +1;
							end;
						end;
					end;
					else do;
						indkey[mpairs+counter, 1:9] = step3 || "->" || "YDiff";
						counter = counter + 1;
					end;
				end;
			end;
			else do;
				indkey[mpairs+counter,1:7] = step2|| "->" || "YDiff";
				counter = counter + 1;
			end;
		end;
	end;
   stpit:
   end;
 end;
 empty = j(20, 1, " ");
 print indkey [label = "Indirect effect key" rowname=m2lab colname = empty];
 if ((contrast=1) & (mpairs > 1)) then;do;
  contlab="(C1)"//"(C2)"//"(C3)"//"(C4)"//"(C5)"//"(C6)"//"(C7)"//"(C8)"//"(C9)"//"(C10)";
  contlab=contlab//"(C11)"//"(C12)"//"(C13)"//"(C14)"//"(C15)"//"(C16)"//"(C17)"//"(C18)"//"(C19)"//"(C20)";
  contlab=contlab//"(C21)"//"(C22)"//"(C23)"//"(C24)"//"(C25)"//"(C26)"//"(C27)"//"(C28)"//"(C29)"//"(C30)";
  contlab=contlab//"(C31)"//"(C32)"//"(C33)"//"(C34)"//"(C35)"//"(C36)"//"(C37)"//"(C38)"//"(C39)"//"(C40)";
  contlab=contlab//"(C41)"//"(C42)"//"(C43)"//"(C44)"//"(C45)";
  print contres [label="Pairwise Contrasts Between Specific Indirect Effects" rowname=contlab colname=indlabs format=&decimals];
  contkey = " "||" "||" ";
  do i = 1 to (nrow(indres)-2);
    do j = i+1 to (nrow(indres)-1);
	  tttt=mlab[1,i]||" - "|| mlab[1,j];
	  contkey=contkey//tttt;
	end;
  end;
  contkey=contkey[2:nrow(contkey),];
  print contkey [label = "Contrast definitions:" rowname = contlab];
 end;
end;*6;
if ((model = 2) | (model = 3)) then; do; *11;
	print "****************************************************************************************";
	coeflabs = {"Effect" "SE" "t" "p" "LLCI" "ULCI"};
	XYgWlabs = wnames || coeflabs;
	print XYgWRes [label = "Conditional Effect of 'X' on Y at values of moderator(s)" colname = XYgWlabs rowname = " " format = &decimals];
	print df2 [label = "Degrees of freedom for all conditional effects:"];
	if (quantile = 1) then print "Values for quantitative moderators are 10th, 25th, 50th, 75th, and 90th percentile.";
	if (quantile = 0) then print "Values for quantitative moderators are the mean and plus/minus one SD from the mean.";
	if (dich[+,1] > 0) then print  "Values for dichotomous moderators are the two values of the moderator.";
	if (setswv > 0) then; do;
		print "---------------------------------------------------------------------------------------------";
		print wvres [label = "Conditional effect of 'X' on Y at requested values of moderator(s)" colname = XYgWlabs rowname = " " format = &decimals];
		print df2 [label = "Degrees of freedom for all conditional effects:"];
	end;
	if (jn = 1) then; do;
		print "*************************** JOHNSON-NEYMAN PROCEDURE ******************************";
		if (numJN ^= 0) then; do;
			print (JNsoln || t(pcntabv)) [label = "Moderator value(s) defining Johnson-Neyman significance region(s) and percent of observed data above value:" colname = {"Value" "% Abv"} format = &decimals];
			print JNRes [label = "Conditional Effect of 'X' on Y at values of moderator" colname = XYgWlabs rowname = " " format = &decimals];
			print df2 [label = "Degrees of freedom for all conditional effects:"];
		end;
		if (numJN = 0) then print "There are no statistically significant transition points within the observed range of data.";
	end;
	print "****************************************************************************************";
	print "Conditional Effect of Moderator(s) on Y in each Condition";
	print (ynames[1,1]) [label = "Condition 1 Outcome:"];
	print (prbmsum[1,]) [label = "Model Summary" colname = clab rowname = " " format = &decimals];
	print (prbmdres[1:(nrow(prbmdres)/2), ]) [label = "Model" rowname = modlabs colname = coeflabs format = &decimals];
	print probedf2 [label = "Degrees of freedom for all conditional effects:"];
	print "----------------------------------------------------------------------------------------";
	print (ynames[1,2]) [label = "Condition 2 Outcome:"];
	print (prbmsum[2,]) [label = "Model Summary" colname = clab rowname = " " format = &decimals];
	print (prbmdres[(nrow(prbmdres)/2 + 1):nrow(prbmdres), ]) [label = "Model" rowname = modlabs colname = coeflabs format = &decimals];
	print probedf2 [label = "Degrees of freedom for all conditional effects:"];

	if (plot = 1) then; do;
		print "****************************************************************************************";
		plotcol = wnames|| "Ydiff" || ynames[1,1] || ynames[1,2];
		print plotdat [label = "Data for visualizing conditional effect of 'X' on Y." format = &decimals rowname = " " colname = plotcol];
		if (center = 1) then print "Note: All moderator values have been centered.";
	end;

end;*11;

end; *5;



print "*************************** ANALYSIS NOTES AND WARNINGS ******************************";
print "Check SAS log for errors.  Do not interpret output if errors are found.";
do i = 1 to nrow(runnotes);
  if (runnotes[i,1]=1) then;do;
    print missing [label="NOTE: Somecases were deleted due to missing data.  The number of cases was:"];
  end;
  if (runnotes[i,1]=2) then;do;
    print "ERROR: Exactly two Y variables must be provided in the Y= list.";
  end;
  if (runnotes[i,1]=3) then;do;
    print samples [label="NOTE: An invalid number of samples was specified.  The number of samples used was:"];
  end;
  if (runnotes[i,1]=4) then;do;
    print "ERROR: The number of samples specified is insufficient for desired confidence.";
	print "Please increase the number of samples or decrease confidence.";
	tttt=conf||samples;
	print tttt [label="Confidence and samples specified:"];
  end;
  if (runnotes[i,1]=5) then;do;
    print "NOTE: The confidence specified was not between 50 and 99.99.  Level of confidence";
	print "was adjusted to 95%.";
  end;
  if (runnotes[i,1]=6) then;do;
    print "ERROR: An even number of variables is required in the M= list.";
  end;
  if (runnotes[i,1]=7) then;do;
    print copyname [label = "ERROR: Two of the specified variables are copies.  The variable names are:"];
  end;
  if (runnotes[i,1]=8) then;do;
    print "ERROR: All specified variables must be unique. No variables may be the same in W, M, and Y.";
  end;
  if (runnotes[i,1]=9) then;do;
    print "NOTE: Both Monte Carlo and bootstrap methods were requested.  Only Monte Carlo CI is provided.";
  end;
  if (runnotes[i,1]=10) then;do;
    print "NOTE: Contrast cannot be constructed with only one pair of mediators.";
  end;
  if (runnotes[i,1]=12) then;do;
    print "NOTE: Monte Carlo confidence intervals are not available for serial mediation";
  end;
  if (runnotes[i,1]=13) then;do;
    print "NOTE: The serial mediation model must have between 2 and 5 pairs of mediators.";
  end;
  if (runnotes[i,1]=14) then;do;
    print badboot [label = "NOTE: Some bootstrap samples had to be replaced. The number of such replacements was:"];
  end;
  if (runnotes[i,1]=15) then;do;
    print "ERROR: At least one W variable and no more than five W variables can be specified in the W list for Models 2 and 3.";
  end;
  if (runnotes[i,1]=16) then;do;
    print "ERROR: Johnson-Neyman procedure not available for models with more than one moderator.";
  end;
  if (runnotes[i,1]=17) then;do;
    print "ERROR: Johnson-Neyman procedure not available for models with a dichtomous moderator.";
  end;
  if (runnotes[i,1]=18) then;do;
    print "ERROR: You must specify a value to probe at for each moderator in the w list. Wmodval lists should be the same length as w list.";
  end;
  if (runnotes[i,1]=19) then;do;
    print "ERROR: Sample size is not large enough. Model is unidentified.";
  end;
  if (runnotes[i,1] = 20) then; do;
  	print "ERROR: Contrasts not available for serial mediation with more than 3 pairs of mediators.";
  end;
  if (runnotes[i,1] = 21) then; do;
  	print "ERROR: Models 2 and 3 require a variable name in the W argument.";
  end;
  if (runnotes[i,1] = 22) then; do;
  	print "ERROR: Model 1 requires at least two variable names in the M argument.";
  end;
  if (runnotes[i,1] = 23) then; do;
  	print "ERROR: Invalid model number. Please select Model 1, 2, or 3.";
  end;
  if (runnotes[i,1] = 24) then; do;
  	print "NOTE: Centering command has no effect for Model 1.";
  end;
end;


if (criterr=0) then;do;*9;
if (model = 1) then; do; *10;
  if ((mc ^= 1) & (bc = 1)) then;do;
    print "Bootstrap confidence interval method: Bias corrected";
  end;
  if ((mc ^= 1) & (bc ^= 1)) then;do;
    print "Bootstrap confidence interval method: Percentile";
  end;
  if (mc = 1) then;do;
    print samples [label="Number of samples for Monte Carlo confidence intervals:"];
  end;
  if (mc ^= 1) then;do;
    print samples [label="Number of samples for bootstrap confidence intervals:"];
  end;
  if (xmint = 1) then; do;
	  centvars = "(" || mnamemat[1,1] || " + " || mnamemat[1,2] || ")/2";
	  if (mpairs > 1) then; do;
		  do j = 2 to mpairs;
		  	temp = "(" || mnamemat[j,1] || " + " || mnamemat[j,2] || ")/2";
		  	centvars = centvars // temp;
		  end;
	  end;
	  print centvars [label = "The following variables were mean centered prior to analysis:"];
  end;
  
  blabs="b1"||"b2"||"b3"||"b4"||"b5"||"b6"||"b7"||"b8"||"b9"||"b10";
  savelab=j(1,3*Mpairs+(cols+serind-mpairs+1)*(serial=1),"           ");
  if (serial = 0) then; do;
	  do i=1 to mpairs;
	    savelab[1,3*i]=mlab[1,i];
	    if (mpairs = 1) then;do;
	      savelab[1,3*i-1]="b";
		  savelab[i,3*i-2]="a";
	    end;
	    if (mpairs ^= 1) then;do;
		  savelab[1,3*i-1]=blabs[1,i];
		  savelab[1,3*i-2]=alabs[1,i];
	    end;
	  end;
	  savelab[1,(ncol(savelab)-2):(ncol(savelab))]="TotalIndirect"||"Direct"||"Total";
  end;
  if (serial = 1) then; do;
  	savelab[1,1:3] = "a1"||"b1"||"Ind1";
	do i = 2 to Mpairs;
		savelab[1,(2*i):(2*i+1)] = blabs[1,i]||mlab[1,i];
	end;
	if (xmint = 1) then; do;
		serlab = 'a2'||'d1'||'f1'||'a3'||'d2'||'f2'||'d3'||'f3'||'a4'||'d4'||'f4'||'d5'||'f5'||'d6'||'f6'||'a5'||'d7'||'f7'||'d8'||'f8'||'d9'||'f9'||'d10'||'f10';
		savelab[1,(2+2*mpairs):(2*mpairs+mpairs**2)] = serlab[1,1:(mpairs**2-1)];
		savelab[1,(2*mpairs+mpairs**2+1):(2*mpairs+mpairs**2+serind)] = mlab[1,(nrow(indres) - serind):(nrow(indres)-1)];
	end;
	if (xmint = 0) then; do;
		serlab = 'a2'||'d1'||'a3'||'d2'||'d3'||'a4'||'d4'||'d5'||'d6'||'a5'||'d7'||'d8'||'d9'||'d10';
		savelab[1,(2+2*mpairs):(1+2*mpairs+cols)] = serlab[1,1:cols];
		savelab[1,(2+2*mpairs+cols):(1+2*mpairs+cols+serind)] = mlab[1,(nrow(indres) - serind):(nrow(indres)-1)];
	end;
	savelab[1,(ncol(savelab)-2):(ncol(savelab))] = "TotalIndirect" || "Direct" || "Total";
end;

  if ((savboot=1) & (mc = 1)) then;do;
    savelab=savelab||"TotalIndirect";
    create &save from mcsave [colname=savelab];
    append from mcsave;
  end;
  if ((savboot=1) & (mc ^= 1)) then;do;
    create &save from bootsave [colname=savelab];
    append from bootsave;
  end;



end; *10;
	print conf [label = "Level of confidence for all confidence intervals in output:"];
	if (((model = 2) | (model = 3))&(center = 1)) then; do;
	  centvars = wnames;
	  print centvars [label = "The following variables were mean centered prior to analysis:"];
	end;
end;*9;
quit;
%mend;
